# Концепции #

* [API: Протокол управления и сбора данных](API.md)

## Переносимость исходноо кода ##
Операционная система - это ядро, библиотеки функий и множество инструментов (утилит). 

Существует два уровня абстракции. 
1. Соответствие стандарту переносимой операционной системы (англ. Portable OS)[POSIX.1-2024][]
2. Использование только тех библиотек, которые представлены на всех целевых платформах и обладают открытым исходным кодом.

Для переносимости между микроконтроллерами под управлением RTOS и POSIX мы используем общепринятые стандартные классы. 

Для работы нужна стандартная библиотека общепринятых классов, таких как спики, динамические массивы и строки, деревья, хеш-таблицы, функции разбора опций командной строки. Все эти элементы мы используем из библиотеки [glib](https://docs.gtk.org/glib/).

## Явная типизация данных ##

Основная путаница и источник ошибок при переносе кода между 64 битными платформами и 32 битными возникает с приведением типов данных, выравниванием и размером элементов структур.
Мы требуем переносимость кода между платформами Intel x86_64, ARM Aarch64, ARM Cortex-A (32 бит), ARM Cortex-M (32 бит). Кроме машинных типов, существует еще ряд системно зависимых типов, которые приводятся к разрядности указателей и разрядности файловой системы: size_t - размеры данных в байтах, off_t - смещения в файловой системе. 

Разница будет по типам данных int, long, long long, машинным типам intptr_t и системным типам size_t off_t.
| тип		| ILP32 | LLP64 | LP64
|----------:|-------|-------|-----
|int		| 4
|long		| 4
|long long	| 8
|intptr_t   | 4
|  size_t	| 4
|   off_t 	| 8

На RTOS мы определяем системыне типы в заголовке <sys/types.h>, откуда их берет компилятор. 


64-bit data models
|model |short|int  |long | long<br/>long|void\* |где встречается
|-----:|-----|-----|-----|-----|-----|------
|ILP32 |16	 |32   |32   |64   |32	 |x32 and arm ilp32 ABIs on Linux systems; MIPS N32 ABI.
|LLP64 |16	 |32   |32   |64   |64	 |Microsoft Windows (x86-64, IA-64, and ARM64); and MinGW
| LP64 |16	 |32   |64   |64   |64	 |Most Unix-like systems, e.g., Solaris, Linux, BSD, macOS.
|ILP64 |16	 |64   |64   |64   |64	 |OS Solaris

POSIХ определяет ряд моделей приведения типов: ILP32 LP64 и LPBIG. Т.е. тип long всегда приравнивается разрядности указателя. 

Рекомендуется использовать *только* явную типизацию числовых типов <stdint.h>. Использование типов int допускается только для переменных регистровых и счетчиков циклов, возвращаемых параметров, значения которых заведомо укладывается в 32 бита. 

Изредака возникают задачи представления указателей в целых чиселах. 
Для этого используется последовательная конвертация `(void*)(uintptr_t)`. Сначала локальный тип приводится к целому числу по разрядности соответствующему указателю, затем к указателю. При использовании конвертации `(void*)(uintptr_t)` компилятор считает что указатель ссылается на данные выровненные в памяти, в то время как `(uint8_t*)(uintptr_t)` ссылкается на данные с выравниванием на байт. 

## Атомарные операции (lock-free) ##

Атомарные операции atomic_fetch_\* и atomic_exchange представлены в стандарте [Си][C] <stdatomic.h>. Атомарные операции на всех используемых платформах начиная с ARM Cortex-M4 и Cortex-M23 имеют аппаратную поддержку эксклюзивного доступа к памяти, это позволяет реализовывать lock-free операции в user-space, без обращения к операционной системе и без задержек. 

На атомарных операциях "чтения с пометкой экслкюзивного доступа"(load exclusive) и "условной записи"(store conditional) реализуются неблокирующие операции добавления элемента в список (стек). 

## Неблокирующие вызовы (wait-free) ##

Мы избегаем использования мьютексов и других элементов синхронизации завязанных на системные вызовы. Всякий системный вызов может вызвать задержку на переключение контекстов и передачу управления другой задаче. Все элементы синхронизации процессов мы реализуем в userspace без ожидания. 

## Сигналы и семафоры ##

Сигналы и семафоры мы определяем на основе атомарных операций. При операциях с сигналами управление не передается операционной системе, т.е. не возникает задержки и не возникает переключения задач. 

## Асинхронная очередь ##

Асинхронная очередь - основной элемент организации потока сообщений между тредами. Асинхронная очередь позволяет без возникновения конфликтов организовать одновременную работу множества писателей и одного получателя. Добавление элементов в очередь - атомарная операция над списками. 
Очередь может быть с приоритетами. POSIX предалагает мутный способ доставки сигналов в треды. Механизм доставки сигналов `sigqueue()` основан на очереди и не поддерживается в ОС Windows. Доставка сигналов предполагается в процесс, по идентификатору процесса, а тред может перехватить сигнал из очереди по маске. Нас такой способ не устраивает, доставка сигналов должна выполняться в треды с использованием неблокирующих вызовов и атомарных операций. На всех платформах используется собственная реализация.

## Выделение памяти из нарезки ##

Операции работы со списками и деревьями требуют большого числа обращений к менеджеру памяти. Мы хотим исключить задержки на выделение и освобождение памяти и требуем, чтобы эти операции выполнялись без обращения к операционной системе и без использования циклов, в одно действие. Такое возможно, если менеджер памяти использует атомарные операции для работы со списками свободных блоков одинакового размера и не использует мьютексы. При работе со списками из нарезки не возникает накладных расходов, т.е. не тратится дополнительная память для хранения вспомогательной информации о блоках памяти. В библиотеке glib представлена реализация метода, см. g_slice_new(), она построена с использованием мьютексов, что не гарантирует отсуствие задержек. При переходе к релизной версии, и на микроконтроллере исопльзуется собственная реализация метода без блокировок и без ожидания. Нарезка из массива позволяет контролировать и отлаживать утечки памяти, поскольку всегда можно определить число блоков в списке и принадлежность блока массиву в операциях освобождения памяти. 

## Треды и примитивы синхронизации ##

в стандарт POSIX входит спецификация pthread_. В новых версиях RTOS мы поддерживаем вызовы pthread, но вместе с тем предлагаем использовать уровень абстракции - C1x треды <therad.h> для облегчения переноса кода между RTOS и POSIX. 

Мы применяем метод запуска тредов с одиной и тойже функцией с разными контекстами (GThreadPool). Такой метод запуска применяется для обработки сетевых запросов. Метод резервирует некоторое количество слотов для асинхронной обработки запросов. Метод содержит счетчик семафора - число свободных слотов, который позволяет выполнять ожидание свободного слота. 

## Статические конструкторы ##

В коде мы используем статические конструкторы и деструкторы. Это позволяет подготовить структуры данных до использования и до старта основного кода в main(). Конструкторы используются для статической регистрации классов, методов и объектов управления. 

## Статическая регистрация сервисов ##

Мы применяем концепцию модульного программного обеспечения, когда состав программы (ядра ОС) определяется скомпонованными (подгруженными) модулями. Для статической регистрации модулей используются статические конструкторы. Модули регистрируются в качестве сервисов со своим номером SAP (Service Access Point) и обрабатывают запросы системного протокола. 

## Системный протокол ##

Системный протокол APDU использует метод кодирования CBOR и методы совместимые с кодировнаием CoAP, позволяющие выполнять маршрутизацию запросов в сети MS-TP (сокр. Master-Slave Token-Pass, с передачей функции мастера). 

Протокол SNMP протостого управления не использует разметку. 

В запросе старшие 3 бита - код интерфейса, младшие 0..23 идентификатор линии, затем следует номер SAP.
+ `0x00`	-- подтверждение получения ACK
+ `0x20`	-- блочный трансфер, запрос фрагмента
+ `0x60` 	-- синхронизация и метки времени
+ `0xC0 nn` -- простое управление без структуризации
+ `0xA0 nn` -- команды прикладного протокола APDU с кодированием CBOR

Отклик в старших битах содержит код завершения операции

Коды отклика (старшие 3 бита):
- `0x00` -- нормальное завершение ACK
- `0x20` -- блочный трансфер, ACK|MOR
- `0x80` -- ошибка в запросе, ERR коды 4.00..4.31
- `0xA0` -- ошибка сервиса,   ERR коды 5.00..5.31
- `0xE0` -- уведомления и сбытия (Abort,Disconnect,Lost), коды 7.00..7.31

|команды   `SNMP`   |nn  | Пояснения
|:------------------|----|----
|_SNMP_FLASH_ISP	|0x61| режим загрузки обновления
|_SNMP_FLASH_COPY	|0x62| проверка целостности и прошивка
|_SNMP_FLASH_CRC	|0xE2| запрос контрольной суммы
|_SNMP_SOFT_RESET	|0x70| перезагрузка без подтверждения
|_SNMP_GET_VERSION	|0xF1| (tstr) версия 
|_SNMP_GET_SUPPORTED|0xF2| (bits) поддерживаемые команды 
|_SNMP_TRACE		|0xFE| (tits) опрос журнала сообщений 

|команды   `APDU`   |nn| rts-m -- параметры
|:------------------|--|-----
|_CMD_RD_FILE		| 6| id n range
|_CMD_WR_FILE		| 7| id n range params[bstr+]
|_CMD_ADD_LIST_ELEM	| 8| id n range params{}
|_CMD_DEL_LIST_ELEM	| 9| id n range
|_CMD_CREATE_OBJECT	|10| rt   params{}
|_CMD_DELETE_OBJECT	|11| id 
|_CMD_RD_PROPERTY	|12| id n range
|_CMD_RD_MULTIPLE	|14| id n params[sndv+]
|_CMD_WR_PROPERTY	|15| id n params{}
* в таблице представлены коды с потверждением получения

Cписок параметров соединения `rts-m` кодируется методом [CoAP.options](#options):
- (7..5) cтаршие три бита содержат идентификатор параметра запроса, 
- (4..0) младшие - длину поля. 

Если в пакете присутствуют вложенные данные `params`, данные отделяются меткой `0xFF` и кодируются CBOR. 
Параметры запроса при передаче в протоколе CoAP кодируются, 
как опция `uri_query` с строка значений `key=value` разделителем полей '&'. 

| key | # | тип  | назначение
|-----|---|------|-----
|di   | 0 | uint | идентификатор устойства
|id   | 1 | sdnv | идентификатор oid (rt,ins)
|rt   | 1 | uint | идентификатор типа ресурса
|n    | 2 | sdnv | путь к параметру в структуре
|range| 3 | uint+| начальный и конечный элемент 
|pdu  | 7 | cbor | параметры протокола

* Текстовое представление sdnv - записывается десятичными цифрами через разделитель '.', 
* Текстовое представление uint+ - записывается целыми числами через разделитель ','. 
* Текстовое представление 'oid=res@nn' преобразуется в sdnv.

Для отладки сообщений используется текстовое представление форматов и разметка в стиле Json без кавычек при отображении идентификаторов. 

## Моделирование данных ##

[ISO/IEC 30118-1 Open Connectivity Foundation -- ] - стандарт, включающий методы взаимодействия и имена полей различных объектов управления. Части действующего стандрата можно скачать с сайта организации.

Стандарт предлагает в качестве идентификаторов объектов использовать URI сылки на модели данных. Это кажется грамоздким. В нашей реализации используются локальные OID и пути образованные контекстными идентификаторами.

### Интерфейсы и политики доступа ###

Ресурсы могут поддерживать нексколько классов, обращение к интерфейсу - это набор параметров соответствующий классу рессурса. Чтобы представить суть, надо понимать, как работает обращение к элементу структуры в Си по имени элемента.

Обращение (SubClass_t\*)((Object_t\*)object +1) позволяет получить адрес структуры, которая уложена после шапки типа Object_t.
Выражение (void\*)data + offsetof(Object_t, element) позволяет обратиться к элементу структуры по адресу, т.е из ссылки на объект получить ссылку на класс. Такие выражения встречаются при описании модели данных для ресурсов с несколькими интерфейсами. Каждому интерфейсу в модели соотвествует смещение класса входящего в состав данного.

### Модель Resource ###

Устройство содержит список ресурсов определенного типа. Перечень типов ресурсво - это свойство устройства. 

### Субкласс Sensor ###

Сенсор позволяет читать последовательно с метками времени (`timestamp`), когда произвдено измерение. Сенсор поддерживает буферизацию при чтении (асинхронную очередь fifo) и поддерживает подписку в форме GET.observe с параметром `max-age`. 
- `value`  - выходное значение, $value = v \cdot factor + offset$
- `factor` - масштабный коэффициент 
- `offset` - смещение
- `units`  - единицы измерения

Локально подписка может быть оформлена от имени процесса (pid), с указанием номера сигнала (signo). 
Доставка сообщений выполняется по принципу sigqueue(pid, signo, sigval) - очереди доставки сообщений [POSIX.sigqueue]. 
Альтернативно поддерживаеся Асинхрнный ввод вывод [POSIX.AIO].

При последовательном чтении очереди используются параметры:
- `timestamp` - штамп времени последнего обновления
- `seqno` 	 - счетчик числа циклов обновления

На RTOS мы поддерживаем атомарные флаги сигналов и вызов функции активации треда по идентификатору треда, 
которая работает аналогично `sigqueue(pid, int signo, union sigval)`. В качестве параметра sigval передается ссылка на элемент очереди.

### Класс Device ###

Устройство содержит: 
- коллекцию объектов в форме реестра `DATASET` с поиском в дереве по идентификатору OID;
- список поддерживаемых типов ресурсов `rts`. 

### Субкласс Process ###

На устройстве могут запускаться процессы, которые участвуют в обмене данными. В частности, нас интересует способ доставки сообщений процессу на удаленной машине. Адресация в этом случае выполняется в сязке $devId/event(pid, signo, sigval) - процесс с заданным номером процесса и номером сигнала. 

### Класс Network ###

Экспоритиует список обнаруженных сетевых устройств. 

### Класс Bus ###

Экспоритиует список адресов обнаруженных устройств на линии сбора данных. 

Каждая линия сбора данных - отдельный тред. Асинхронная линия сбора данных может порождать второй тред на прием данных. 

Линия поддерживает абстракцию методов CRUDN. Под каждым методом понимается некоторая последовательность и порядок обмена. 

## Системный протокол ##

Передача структурированных данных между процессами, между ядрами, в условиях гетерогенных архитектур требует копирования данных, используется сериализация данных и интерфейс Message Passing. Системный протокол строится на понятии service access point - аналогично port в модели Socket. С адресацией $NetworkID+$DevID+$sap. Для вложенных структурированных и типизованных данных предлагается использовать кодирование CBOR. 

## Модель GPIO-v2 ##

Относительно новый способ работы с портами ввода-вывода. Потры разделены на группы на разных платформах порты могут иметь различную разрядность 8,16,32,64 бита. Мы принимаем модель описания портов GPIO-V2, принятый в Linux. На голой платформе мы используем свой способ статический описания портов, который можно привести к модели Linux. 

Статический сопособ описания включает:
1. Идентификатор аппаратуры порта (gpiochip#, GPIOA..GPIOF)
2. Имя порта, как оно отображется в системе, для диагностики.
3. Маска используемых линий порта
4. Флаги: INPUT,OUTPUT которые можно комбинировать с флагами BIAS_PULLUP, BIAS_PULLDOWN или PUSH_PULL, OPEN_DRAIN и атрибутами, включая полярность сигналов ACTIVE_LOW, ACTIVE_HIGH и EDGE_RISING, EDGE_FALLING. 
5. Линии могут быть настроены на специальную функцию, например, I2С, SPI или UART. Это определяется вариантом ALT# - алтернативаня функция порта.
6. Атрибуты: Начальное состояние линий OUTPUT задается маской. 

Для статического описания GPIO используется таблица GPIO_Config, которая обрабатывается до запуска main() и до запуска статических конструкторов (низкоуровневая инициализация). Вся структура GPIO_Config описывается в файле заголовка "board.h"

Интерфейс работы с портом включет операции _set, _reset, _set_reset по маске, которые должны иметь аппаратную поддержку, обеспечивающую одновременное изменение сигналов. Понятие маски отличается при статическом описании используются смещения - физическая нумерация линий. А при работе с настроенным портом логическая организация - номер линии заданный при перечислении. При чтении с порта возвращается маска линий. gpio_port_state - возвращает логическую маску с учетом полярности сигналов и признаков EDGE - детектирование фронтов.


При работе с портом используется дескриптор порта:
```c
int fd =  gpio_port_open(gpiochip_id, name, offsets[], flags, attrs);
val = gpio_port_get(fd, mask);
gpio_port_set_reset(fd, mask_set, mask_reset);
gpio_port_close(fd);
```
offsets применяются относительно идентификатора gpiochip_id. Если смещение превышает ширину порта, то линия может быть использована из следующего порта. Таким образом можно группировать линии с разных портов, но не гарантируется, что такая возможность поддерживается. 

Настройка дополнительных параметров порта может быть выполнена с использованием метода реконфигурации порта, атрибуты применяются по маске порта. 
```c
gpio_port_config(fd, flags, attrs);
```

Можно выполнять ожидание события порта по дескриптору порта с использованием системной функции poll() [POSIX.poll]. Чтение порта `read(fd)` возвращает структуру содержащую маску (все линии gpiochip, не путать с маской порта), 
счетчик событий и метку времени срабатывания (если такой функционал поддерживается аппаратно). 
На этой функции строится измерение временных интервалов на линиях GPIO. В частности таким образом подключается внешняя синхронизация и импульсные счетчики-расходомеры, счетчики-электроэнергии, счетчики оборотов двигателя. Для них вводится специальный класс Счетчики. Для счетчиков задается дробью (десятичной или рациональным числом) коэффициент пересчета импульсов в физические единицы измерения. Задается также параметр усреднения показаний по времени. 

Класс `CNT`, вводится поверх GPIO+TIM и может содержать измерение длительности сигналов или периодичности по фронту импульсов. 

Класс `PWM`, вводится поверх GPIO+TIM. Класс позволяет задавать ряд параметров, включая: период, минимальную, максимальную длительность импульса в наносекундах; полярность выходного сигнала. Класс используется для управления помпами водяного охлаждения, вентиляторами, серво-приводами, термостатическими клапанами. 

Класс `REL`, релейные контакты для контроля состояния линии типа Smart Switch используется ассоциированная линия GPIO с сигналом "перегрузка" или "обрыв". 

## Интерфейс Stream Driver ##

* Stream Driver - интерфейс поддерживающий ряд стандратных методов (open, send, recv, close, ioctl). 
* CDC -- сокр. Communication Device Class, набор команд стандартизированных в субклассе устройств USB CDC.

+ USB+CDC устройство прикидывается Stream Driver и поддерживает CDC команды через ioctl. 
+ TTY+CDC устройство поддерживает

Метод `open(path, port_settings)`
- port_settings - строка параметров с `key=value` разделителем '&'.



## Трансфинитные числа и вполне упорядоченные множества ##

Довольно странный концепт, рождается в отношении упорядоченных множеств для параллельных расчетов. 

Трансфинитные числа (от транс… и лат. finitus — ограниченный), обобщённые порядковые числа. Определение опирается на понятие вполне упорядоченного множества. Идея соостоит в том, что нет никакой разницы с помощью какого итератора перебираются числа - порядковые номера элементов массива, например. 

Упорядоченные множества - такие множества, к которым мы можем применить функцию сравнения в порядке следования элементов, порядок определяется итератором.

Мы рассматриваем конечное множество чисел от 1 до 2^N и операцию, которая дает перебор всех чисел за 2^N - 1 шагов. 
У трансфинитных чисел есть и братное число, которое прямым перебором получается за 2^N-2 операций.

К таким операция относятся коды Грея и циклические коды CRC основанные на нередуцируемых полиномах и арифметике Галуа. Мы вводим класс итератор и дополнительно функцию, которая дает константу смещенную на M шагов. К таким итератором будет относится генерация последовательности псевдо-случайных чисел, например MWC128, MWC64 основанные на сложении и умножении с переносом в конечном поле и модульной арифметике. Класс итератор используется в тех случаях, когда нужно получить равномерное распределение. К итераторам относится и выборка из массива в произвольном порядке с заданным шагом. К итераторам относится хождение по элементам списка, потому что для объекта сипсок можно предложить функцию next и переход к элементу с номером N. Существуют более сложные математические структуры, которые можно назвать итератором, например эллиптическая криптография, аналогом которой является положение стрелки на часах. 


На итераторах строится языковая конструкция 
```js
foreach(Iter(X) as i) {
	. . . 
}
```

Так можно сказать про перебор элементов списка, перебор элементов массива. Языковая конструкция поддается паралелльной обработке, потому что для нее можно задать начальный элемент перебора и число шагов.

Этот концепт годится и для математических расчетов, для которых входным параметром является поток псевдослучайных чисел.
Для равномерности покрытия поля в нашей концепции итераторы используются для генерации адресов устройств, для генерации нонсов в системе безопасности, для генерации начальных значений математических расчетов. 

С трансфинитными множествами связано понятие аффинных (обратимых линейных) преобразований. Множество чисел одной размерности может иметь функцию и или таблицу отображения в другое множество со своей операцией перебора. Каждому элементу одного множества сопоставляетя элемент другого множества. 

В системе команд Intel пристуствует поддержка аффиных пребразований, которая позволяет переставлять и перемешивать биты числа. В сочетании с утверждением, что все конечные поля данной разрядности изоморфны между собой, становится понятным, что на базе арифметики в конечном поле с одним полиномом можно выразить операции в другом изоморфном ему поле.  

Если кому-то эти утверждения кажутся странными, то надо понимать, что производительность на инструкциях не человеческих может быть выше и это может быть делом компилятора найти такое изоморфное преобразование итератора, при котором вычисления производятся быстрее и эффективнее.

Кроме того мы рассматриваем применение трансфинитных чисел для оптимизации выборки и хранения. Для равномерной загрузки вычислительных ресурсов. 

Так например, мы используем аффинные пребразования идентификаторов объектов, чтобы в результате процесса развертывания системы получиось равномерное заполнение дерева объектов при последовательном назначении идентификаторов, чтобы не требовалась балансировка дерева, чтобы дерево рождалось сбалансированным. 

На итераторах в конечном может быть основано шифрование, Counter Mode выполняет замешивание исходного вектора с использованием счетчика, такой же результат в плане устойчивости получается с использованием трнасфинитных чисел. 

### Трансфинитная индукция ###

Известен метод доказательства - математическая индукция. Если утверждение истинно для первого элемента множества, а последующие элементы множества можно получить с использованием итератора, и следствием истинности N элемента является истинность N+1 -го элемента, то по индукции доказана истинность утверждения для всех элементов множества. Такой же метод работает с использованием трансфинитных чисел. 

- $x^{16} + x^9 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + 1 $
- $x^{16} + x^{12} + x^3 + x^1 + 1 $
- $x^{16} + x^{12} + x^7 + x^2 + 1 $
- $x^{16} + x^{13} + x^{12} + x^{10} + x^9 + x^7 + x^6 + x^1 + 1 $
- $x^{16} + x^{13} + x^{12} + x^{11} + x^7 + x^6 + x^3 + x^1 + 1 $
- $x^{16} + x^{13} + x^{12} + x^{11} + x^{10} + x^6 + x^2 + x^1 + 1 $
- $x^{16} + x^{14} + x^{10} + x^8 + x^3 + x^1 + 1 $
- $x^{16} + x^{14} + x^{13} + x^{12} + x^6 + x^5 + x^3 + x^2 + 1 $
- $x^{16} + x^{14} + x^{13} + x^{12} + x^{10} + x^7 + 1 $
- $x^{16} + x^{15} + x^{10} + x^6 + x^5 + x^3 + x^2 + x^1 + 1 $
- $x^{16} + x^{15} + x^{11} + x^9  + x^8 + x^7 + x^5 + x^4 + x^2 + x^1 + 1 $
- $x^{16} + x^{15} + x^{11} + x^{10}       + x^7 + x^6 + x^5 + x^3 + x^2 + x^1 + 1 $
- $x^{16} + x^{15} + x^{11} + x^{10} + x^9       + x^6       + x^2 + x^1 + 1 $
- $x^{16} + x^{15} + x^{11} + x^{10} + x^9 + x^8 + x^6 + x^4 + x^2 + x^1 + 1 $

Трансфинитная индукция - метод доказательства, который используется математической логике и логике высказываний при переходе от натуральных чисел к трансфинитным. На данном этапе развития ПО не вполне понятно при чем тут мат.логика и в каком контексте используется Решатель задач...  

## Расширения языка Си ##

### Векторные типы данных ###

### Псевдофункиции и Intrinsics ###

* [[ARM.acle](https://github.com/ARM-software/acle)] "Arm C Language Extensions", Version: 2024Q2