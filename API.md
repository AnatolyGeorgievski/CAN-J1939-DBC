# Протокол управления и сбора данных #

Автор:
* __[Анатолий Георгиевский](https://github.com/AnatolyGeorgievski)__


Типы обмена бывают: 
```
.subscribe 	- (list) подписка на события, 
.notify 	- уведомления от сервера - команды и сообщения без подтверждения, 
.submit 	- (отсылка результатов, publish), 
.authorize, .configure, 
.create - (oid; params)  -- создание объекта
.delete   (oid)          -- удалить объект
.add_list (oid, pos; params), -- добавть элемент списка
.remove_list(oid, pos),  -- удалить из списка элемент
.set	(obj;params),    -- установка параметров объекта
.get	(obj;params),    -- запрос параметров объекта
.range	(obj, pos, len), -- чтение списка
```

В качестве примера рассмотрим типы сервисов с подтверждением, протокол BACnet для автоматизации зданий:
```c
const char* confirmed_services[]={ // названия сервисов BACnet с подтверждением
[ 0]= "acknowledge-alarm (0)",
[ 1]= "confirmed-cov-notification (1)",
[ 2]= "confirmed-event-notification (2)",
[ 3]= "get-alarm-summary (3)",
[ 4]= "get-enrollment-summary (4)",
[ 5]= "subscribe-cov (5)",
/// File Access Services
[ 6]= "atomic-read-file (6)",
[ 7]= "atomic-write-file (7)",
/// Object Access Services:
[ 8]= "add-list-element (8)",
[ 9]= "remove-list-element (9)",
[10]= "create-object (10)",
[11]= "delete-object (11)",
[12]= "read-property (12)",
[14]= "read-property-multiple (14)",
[15]= "write-property (15)",
};
```

Так выглядит описание полей и идентификаторов на языке Си:
```c
#define HBOARD_NS \
	_(asic),_(chips),_(cols),_(sens),_(baud),_(tfreq),\
	_(hrate),_(perf),_(effi),_(freq),_(temp),_(tune)
#define _(x) HBOARD_##x
enum {HBOARD_NS, HBOARD_COUNT};
static const ObjectProperty_t _hboard[HBOARD_COUNT] = {
[_(asic)]	={T(UINT),	OF(Board_t, asic_id),		.read_only=1},
[_(chips)]	={T(UINT),	OF(Board_t, chain_length),	.read_only=1},
[_(cols)]	={T(UINT),	OF(Board_t, chain_cols),	.read_only=1},
[_(sens)]	={T(UINT),	OF(Board_t, num_sensors),	.read_only=1},
[_(hrate)]	={T(REAL),	OF(Board_t, hashrate)		},//!< число хешей в секунду
[_(perf)]	={T(REAL),	OF(Board_t, perfomance)		},//!< число хешей на гигагерц
[_(effi)]	={T(REAL),	OF(Board_t, efficiency)		},//!< энергоэффективность
[_(freq)]	={T(REAL),	OF(Board_t, frequency)		},//!< тактовая частота, текущая
[_(temp)]	={T(REAL),	OF(Board_t, temperature)	},//!< средняя температура
[_(tune)]=	{ARRAY_OF(SINT8),OF(Board_t, freq_adjust[0])},
};
```
Кроме описания свойств есть еще описание интерфейсов и описание класса объекта, которое также синтезируется из модели. 
```c
#define _(x) #x
static const ObjectClass_t _hboard_cl = {
	.rt  = RT(brd), .ns = (const char*[]){HBOARD_NS}, 
	.rep =_hboard,
};
```
В составе объетка пристуствует
- тип ресурса (rt)
- пространство имен (ns)
- внешнее представление (rep)
- политики взаимодействия (p), соответствуют наборами свойств:
  + содержит привязку к классу и наблюдаемым параметрам (discoverable) 
  + отслеживает и пбуликует список параметров (observable)
  + является получателем уведомлений NOTIFY (pushable). 

Политика discoverable означает, что объект приводится к классу Resource и к нему могут применяться методы настройки и опроса параметров, такие как get_params, set_params.


Еще в коде присутсвтуют статические конструкторы и деструкторы для классов и объектов управления. 
```c
static void __attribute__((constructor)) _object_type_init();
static void __attribute__((destructor))  _object_type_fini();
```
Подобные структуры данных могут синтезироваться из модели автоматически, вместе с описанием интерфейсов и конструкторами классов. 

## Общие требования ##

При обмене запрос-ответ применяется адресация объектов через идентификатор объекта OID. 

**Глобальный индентификатор OID** представляет собой путь от корня директории с разделителями '.'. Путь может содержать имена и числовые (контекстные) идентификаторы. Глобальные идентификаторы начинаются с разделителя.

**Локальный индентификатор OID** формируется из сокращенного имени типа ресурса (`rt`, resource type) и порядкового номера (`ins`) "brd@1" "dev@0" через разделитель '@'. 
Запись "pool" - номер не определен, - такая форма используется при создании объекта. 
В ответе передается идентификатор созданного оъекта в форме OID.

**Контекстные идентификаторы**. При адресации параметров используются последовательности идентификаторов состоящие из перечисления имен параметров и/или из перечисления позиционных(контекстных) идентификаторов и индексов структур. Позиционные идентификаторы параметров нумеруются от единицы (1). Позиционный идентификатор (0) адресует всю структуру. Адресация таким образом задается относительно локального идентификатора объекта. Последовательность позиционных идентификаторов кодируется, как (sdnv, Self-Delimiting Numeric Values) - числовые последовательности со встроенными разделителями. Список параметров, передаваемый в запросе, может быть представлен именами, контекстными идентификаторами(sdnv) и числами. 

В том случае, когда имя параметра запроса, передаваемого в форме строки, содержит число в первом байте - это число интерпретируется, как байтовая, строка содержащая кодовую последовательнось _BSTR_SDNV. Идентификаторы текстовые напротив не могут содержать число в первом символе имени. 

Команды бывают запрос-ответ (GET, PUT), и уведомления от устройства (NOTIFY). Чтобы получать пакеты уведомления, нужна подписка. Подписка существует в рамках протокола MQTT и CoAP. В протоколе CoAP подписка действует в течение сессии. Подписка иницируется опцией observe в пакете типа GET.Observe. Запрос должен содержать уникальный номер запроса, токен (id), который возвращается с ответом. 

Локальные имена типов ресурсов (`rt`) должны состоять из трех или четырех букв (сокращенное имя). Это искусственое ограничение применяется ради упрощения процедуры сопоставления имен, см. соглашение о сокращенных именах. Фактически мы говорим о сопоставлении локальных и глобальных идентификаторов типов ресурсов. Список таких сокращений - свойство устройства. В процессе распознавания устройств, мы можем запросить список используемых локальных идентификаторов ресурсов `rts`.

Мы резервируем множество сокращенных идентификаторов `rts` для обозначения классов устройств:
```c
const char* _object_names[] = {
ID(any),ID(adc),ID(brd),ID(bus),ID(can),ID(cpu),ID(dac),ID(dev),ID(dir),ID(fan),ID(file),ID(gpio),ID(i2c),
ID(lnk),ID(net),ID(shm),ID(spi),ID(tty),ID(uart),ID(usb),ID(psu),ID(pwm),ID(tim)
};
```

Маршрутизация запросов основана на коллекциях ресурсов. Устройство может поддерживать несколько сетей и выполнять маршрутизацию запросов между сетями. Объект типа network или bus экспортирует множество адресуемых устройств. Полный путь к устройству может быть составным "/dev/net@1/dev@101/brd@1" или "/dev/usb@1/i2c@1/mem@21" или "/dev/i2c@1/lm75@80"... Путь uri_path может содержать локальные идентификаторы или имена устройств. Ресурсы обладающие свойством discoverable имеют локальный идентификатор в форме {\$rt@nn} и имя уникальное в коллекции {\$n}. 


Каждый объект в коллекциях должен экспортировать свойства: oid, name. Корневой объект "dev@0" должен иметь уникальное имя в сети, и уникальный серийный номер `ins`. Каждый объект должен иметь список доступных параметров `rts`, из которого выделяется  обязательный набор `rts-m` для целостности запросов и полноты ответов выбранного интерфейса взаимодействия с объектом (`if`). 

Мы предусматриваем процедуру развертывания сети устройств, которая предполагает отсылку уведомлений о присутствии в локальной сети. И возможность назначения конфигурации `config` по уникальному идентификатору `ins`. Автоматическую процедуру обновления прошивок `firmware` устройств. 


## Сетевая модель ##

Класс `bus` экспортирует коллекцию устройств с возможностью адресации по `ins` - уникальному адресу на линии.

Класс `usb` экспортирует с возможностью выборки по "PID=&VID=" и ins={Serial}. Серийный или порядковый номер попадает в `ins`. "Экспорт" - это интерфейс взаимодействия с устройством, который позволяет создать ресурс по параметрам запроса 
```js
{path:"/dev", port:"PID=&VID=", ins:"...", config="..."}
```

Запись `port:"PID=...&VID=..."` эквивалентна `port:{PID:"...",VID:"..."}`. Формат записи соответствует TSTR_URI_QUERY. Для каждого типа драйвера линии сбора данных набор параметров может быть свой.
Так например, Запись `port:"baudrate=115740&stopbits=2&gpio_rst=119"` в формате TSTR_URI_QUERY пинменяется для создания устройства на линии UART `type:"tty"`.

Рессурс типа `type:"i2c"` экспортирует устройства различного типа с привзкой по адресу. Поддерживает инетерфейс Gateway. 

Рессурс типа `type:"can"` экспортирует устройства по адресам и именам блоков BU и номерам cетевых объектов BO согласно схеме. Коллекция будет содержать сетвеые устройства, блоки и сетевые объекты. Схему можно импортировать в формате [SAE J1939 DBC].

Рерсурс типа `type:"reg"` экспортирует файлы из директории устройства. Объектный идентификатор файла составляется из `rt` и `ins`.

Рерсурс типа `type:"lnk"` содержит символьную ссылку.

Класс `net` экспортирует коллекцию обнаруженных адресов устройств, каждому устройству сопоставляется `ins` и `ep`(endpoint) proxy_uri или список альтернативных способов с разными схемами взаимодействия {proxy_schema '://' proxy_uri}, альтернативные адреса спровождаются параметрами `priority` и `latency`, параметром `content-format`. В сети может быть выделенное устройство, которое поддерживает функцию *Proxy*, *Gateway* и функцию *Router*. Сетевое устройство может поддерживать несколько сетей и для каждой определять набор функций и список `eps` (endpoints). Сети идентифицируются по номеру `ins`. Полный путь для методов протокола относительно данного устройства может содержать два и более элемента в перечислении `/dev/net@1/dev@2/..`

Если мы рассматриваем организацию сети в модели "умный дом", то надо представлять одну или несколько сетей LAN, таких как WiFi или Еthernet, одну и более сетей сбора данных для подключения датчиков и исполнительных устройств, один "облачный" WAN сервис TCP c функцией перенаправления запросов (*Proxy*) к устройству сбора данных в локальной сети. Устройство в свою очередь должно поддерживать кеширование данных и обладать функцией *Gateway* для линий сбора данных датчиков. 
Существует еще одна выделенная роль *KeyServer*, которая поддерживает функции: обмена ключами между устройствами, назначение адресов, раздачу конфигурционных файлов и бинарных пршивок, обеспечивает развертывание сети и замену оборудования. В сети поддерживается возможность публикации уведомлений и подписки на уведомления. 

Если мы рассматриваем модель "контейнер с оборудованием", он будет включать множество устройств и не имеющих прямого выхода во внешнюю сеть. Устройства подписываются на рассылку заданий. Выделенное устройство, которые выполняет роль устройства сбора данных, записывает журнал и поддерживает распознавание сети, поддерживает функцию *Proxy* и *Router*. Выделенное устройство обеспечивает доступ к сети сбора данных: CAN, LIN, I2C, SMBus/PMBus, RS-485, для управления различными параметрами окружения и параметрами размещения оборудования: отоплением, охлаждением, вентиляцией, электрикой, освещением, контролем доступа; распределение, планирование и учет ресурсов на основе критериев энергоэффективность, производительность и т.п. Контейнер поддерживает секционирование, как способ структуризации и организации оборудования. 

В модели "мобильный контейнер" добавится блок GNSS на линии CAN для навигации и глобального позицинирования. 

Протокол сбора данных прикладного уровня описывается абстраткно в терминах {request,response,confirm,indication} с использованием праметров запроса `params` и параметров протокола (id, if, rt,ins, n, oid, range и т.п.), без привязки к схеме взаимодействи и сетевому протоколу. Сервисы протокола работают в разных режимах, с подтверждением получения {`CREATE`, `RETRIEVE`, `UPDATE`, `DELETE`} или без подтверждения `NOTIFY`. Методы `NOTIFY` могут относится к одному устройству или к группе получателей. В рамках данной модели,  может поддерживаться несколько протоколов, выбор протокола определяется компонентой uri_schema сетевого пути, например "coap+tcp", "coap+ws", "mqtt". 

## Инициализация и развертывание ##

Начальная инициализация выполняется с использование конфигурционных файлов в формате Json (см. [config.json](config.json)).  Файл содержит перечисление объектов и списков объектов. 

Ресурс типа `type:"gpio"` позволяют экспортировать параллельный порт с набором линий. Набор линий задается через перечисление номеров линий относящихся к устройству `path:"/dev/gpiochipN", port:[...]`. При опросе порта маска будет содержать биты в порядке линий перечисленном при настройке.

Ресурс типа `type:"pwm"` позволяет экспортировать линии ШИМ контроллера. У настроек есть период обновления `max-age`, если данные не обновляются долгое время, то настройка сбрасывается к значению по умолчанию. Настраивается `period`, `duty_cicle`, `duty_min`, `duty_max` - значения задаются в наносекундах.

Ресурс типа `type:"cnt-gpio"` позволяет экспортировать gpio линии типа `input` для измерения частоты по нарастающему (`egde:"rising"`) или спадающему (`egde:"falling"`) фронту срабатывания. Срабатывание по фронту на одной из линий создает поток событий, на который может быть оформлена подписка. На потоке событий поддерживается интерфейс сбора данных `fifo` и может расчитываться средняя частота следования импульсов (cnt- счетчик), которая с использованием линейной апроксимации преобразуется в величину типа расход. Значение `interval` содержит измеренное время в наносекундах. Значение `seqno` - счетчик числа срабатываний, `timestamp` - штамп времени в наносекундах. 

Передаточная функция фильтра в операторной форме:
$$L_\alpha(z) = \frac{1}{2} \frac{\bar{\alpha}(1+z^{-1})}{1-\alpha z^{-1}}$$	

Ресурс типа `type:"cnt-gpio"` позволяет опрашивать импульсные-счетчики раходомеры. Счетчик привязывается к линиям GPIO `path:"/dev/gpiochipN", port:[...]`. При инициализации настраиваются параметры

- `timestamp` - штамп времени образованный от `CLOCK_MONOTONIC` 
- `seqno` - счетчик срабатываний
- `value` - усредненное выходное значение
- `factor` - коэффициент пересчета выходного значения 
- `offset` - смещение, установлено в 0
- `units` - единицы измерения, напрмер "rpm" или "l/min"
- `interval` - период обновления в наносекундах, по умолчанию 1мс
- `alpha` -  коэффициент сглаживающего фильтра 

Время интегрирования $T_i$ по умолчанию установлено 1 сек. 


Ресурс типа `type:"i2c"` и `type:"i2c_gpio"` инициализируется с использованием параметров назначения линий ввода вывода `port:[ 2, 3]` или `port:{sda:2, scl:3}` или `port:"sda=2&scl=3"` все три варианта записи эквивалентны.

Ресурс типа `type:"spi"` использует параметры инициализации порта `port:"mosi=2&miso=3&clk=4&ce=5&polariy=..."`

Расурс типа `type:"pid"` внешнее представление регулятора, содержит настраиваемые параметры.
Передаточная функция регулятора состоит их трех компонент $P+I+D$, пропорциональной интегральной и дифференциальной, с общим коэффициентом усиления:
$$C(s) = P(s)+I(s)+D(s) = K_p\left(1+\frac{1}{T_i \cdot s} + T_d D(s)\right)$$
Для перехода в Z- пространство используется подстановка
$$s= \frac{2}{T_s} \frac{1-z^{-1}}{1+z^{-1}},$$
где $T_s$ – период дискретизации. 

$$C(z) = g ( \bar{\beta_1} P(z)+\beta_1 I(z)(\bar{\beta_2}+\beta_2 D(z)) )$$
передаточные функции компонент представлены в операторной форме:\
$P(z) = (1-z^{-1})$; $I(z) = (1+z^{-1})/2$; $D(z) = (1-z^{-1})^2 LPF(z)$.

Фильтр $D(z)$ применяется к усредненному значению параметра, $LPF(z)$ - фильтр нижних частот. 

$$C(z) = g \left( \bar{\beta_1}+ \beta_1 \left( \bar{\beta_2} L_1(z) + \beta_2 (1-z^{-1}) L_{\alpha}(z) \right) \right)$

где $L_1(z)$ и $L_{\alpha}(z)$ - фильтры нижних частот с передаточной функцией: 
$$L_1(z) = \frac{1}{2} \frac{1+z^{-1}}{1-z^{-1}} ;
  L_\alpha(z) = \frac{1}{2} \frac{\bar{\alpha}(1+z)}{1-\alpha z^{-1}}$$

Функция настраивается с помощью параметров:
- `interval` - период обновления в наносекундах, по умолчанию 1мс
- `source` - источник сигнала - объект с интерфейсом "Sensor".
- `alpha` - коэффициент сглаживающего фильтра для дифференциальной компоненты
- `beta1` - коэффициент между пропорциональной и интегральной составляющей $[0,1]$
- `beta2` - соотношение дифференциальной и интегральной составляющей
- `gain`  - коэффициент усиления Kp

Коэффициент $\alpha$ выбирается исходя из отношения
$$\alpha = \frac{T_s - 2 T_d/\gamma}{T_s + 2 T_d/\gamma} ,$$
где $T_s$ - период оцифровки, $T_d$ - время  $\gamma$ - эмпирический параметр, выбирается порядка 10 для обеспечения устойчивости алгоритма.

Расурс типа `type:"fir"` фильтр с конечной импульсной характеристикой
- `interval` - период обновления в наносекундах, по умолчанию 1мс. 

Расурс типа `type:"iir"` фильтр с бесконечной импульсной характеристикой
- `interval` - период обновления в наносекундах, по умолчанию 1мс. 

Расурс типа `type:"lms"` фильтр адаптивный
- `interval` - период обновления в наносекундах, по умолчанию 1мс. 

Расурс типа `type:"filter"` настраиваемый фильтр акустический второго порядка

Расурс типа `type:"sos"` настраиваемый фильтр высокого порядка разложенный в каскад секций второго порядка.

- `interval` - период обновления в наносекундах, по умолчанию 1мс. 
- `gain`  - коэффициент усиления
- `units` - единицы измерения. 

Расурс типа `type:"plc"` программируемая логика, логика принятия решения, для отладки функиции в реальном времении.
- `interval` - период обновления в наносекундах

Расурс типа `type:"sfc"` управляющая последовательность, внешнее представление.
Устройство может динамически создавать последовательности исполнения. Ресурс позволяет отслеживать стадию исполнения в последовательности.

- `interval` - период обновления в наносекундах
- `stage` - стадия исполнения, заданная перечислением

Развертывание сети состоящей из `tty` и `usb` устройств будет описываться как 
```json
"bus":[
    {"type":"tty",  "path": "/dev/ttyS0", "port":"baudrate=115740 stopbits=2 gpio_rst=119", "ins":0}
    {"type":"tty",  "path": "/dev/ttyS2", "port":"baudrate=115740 stopbits=2 gpio_rst=118", "ins":2}
	{"type":"usb",  "path": null, "port":"VID=0x9148&PID=0x0004", "ins":"..."}
	]
```

## Моделироване данных ##

Внешнее представление объекта описывается моделью данных или схемой. Одновременно мы поддерживаем представление в формате CBOR и JSON. Оба формата несут не достаточно информации. Основной проблемой совместимости форматов является сопоставление идентификаторов имен полей при разборе структур данных. Само по себе требование сопоставление человекочитаемого описания объекта и бинарное представление полей вызывает лавину взаимосвязанной информации, необходимой для описания данных. Управление этой информацией при передачи данных между сетями и автоматизированное формирование пакетов на основе моделей данных составляет данную тему. 

Мы тут используем терминологию. GQuark - идентификатор по которому возможно однозначно восстановить строку и наоборот, по строке получить его идентификатор. Кварки - составляют словарь, но идентификаторы полей могут иметь контекстную последовательную нумерацию и абсолютные идентификаторы. 
При разборе структуры запрса или ответа могут использоваться позиционные (контекстные) числовые идентификаторы.  

В данном проекте мы используем протокол CoAP для управения и сбора данных. Протокол поддерживает ряд форматов, которые дают возможность такого представления через модели данных. В модели выполняется сопоставление имени класса или имя параметра или имя битового поля, имя константы и соответствующего числового идентификатора. Имена объектов должны иметь уникальный идентификатор OID. 
Протоколу обмена должна соответствовать модель данных. Для моделирования данных рекмендуют пользоваться одним из следующих форматов. 
+ YANG -- язык моделирования данных [[RFC7950]], не нравится
+ CDDL -- язык для определения данных [[RFC8610]]. 

Вместе с тем традиционный способ моделирования данных основан на ASN.1 [[X.680]]. И примером для подражания, по моему мнению, вяляется стандарт [BACnet], 
в котором моделирование основано на ASN.1 и имеет полностью законченную и продуманную сетевую модель и весьма компактный способ кодирования данных. 

Описание данных ASN.1 содержит понятия последовательности структурированных данных, структуры - конструктивные типы SEQUENCE и SEQUENCE_OF, 
множества SET и SET-OF, выбор формата CHOICE.  Каждому из этих представлений можно сопоставить структуры данных в языке программирования. 

Кодирование может быть контекстным прикладным и базовым с явным и неявным использованием идентификаторов - это накладывает свои ограничения на типизацию и представление множеств. Базовыми типами являются NULL, BOOL, UINT, INT, REAL, ENUM, BITS, BSTR, TSTR, TIME, DATE, OID. 
К тому же предлагается некоторое множество вариантов кодирования текстовых и бинарных форматов. 
К типам могут применяться операторы SIZE, RANGE, PATTERN, DEFAULT и др. Язык [ASN.1][] кажется довольно сложным, и явным образом наследует типы форматов. 

C использованием языка ASN.1 можно создавать и описывать различные структурированные бинарные форматы данных. Именно так на протяжении многих лет создавались стандарты сетевых протоколов и описывались структурированные форматы с бинарными сопсобами кодирования BER, DER, XER. 


Для нового бинарного формата надо определить правила кодирования для каждого базового типа и правила кодирорания для каждого структурированного типа. 

На примере кодирования BACnet и BER, 
сравнивая способы кодирования базовых и структурированных типов, я вижу CBOR несколько проще, поскольку исключает контекстные коды. 
Кодирование становится проще и меньше завязано на схему. Но это не существенно. В целом правила кодирования сводятся тому же самому TLV (тип, длина, значение). А кодирование структурных типов вводится через дополнительные теги. 

### Конецепция: кодирование на основе математических классов ###

Кодирование типов может быть основано на математических классах и таких понятиях как: вектор, композиция, тензор, сужение класса с использованием функции, множество, множество констант заданное перечислением, выделенный элемент множества-инвариант, обратное число. Помимо векторов и тензоров, современные методы кодирования могут потребовать использования арифметики с насыщением и понижением разрядности float, чисел с фиксированной точностью, рациональных чисел, больщих чисел для криптографии. 
Это все приводит к тенденции - экспоненциального увеличиения числа форматов и вариантов кодирования/перекодирования или к необходиомости иного подхода к типизации. Иной подход основан на алгебре, теории множеств. Язык внутреннего представления (сокр. IR) оперирует множеством, пространством (множество, разбиение, мера), пространством имен, набором констант, специальным способом записи обратных чисел (множество, константы, операция сопряжения `~`). Например,  кодирование float можно было бы описать разрядностью мантиссы, разрядностью экспоненты и набором констант *NaN*, *+Ininty*, *-Infinity*, 0. Кодирование могло бы дать числа с экспонентой, с мантиссой, со знаком. 
При этом экспонента и мантисса образуют композицию математических классов. Тем же способом можно вводить рациональные числа, комплексные, кватернионы и двоично-десятичные числа, числа с фиксированной точностью и дробные числа (вещественные без экспоненты и без знака). 

В математической логике, применяемой для описания математических языков, используется понятие сигма-алгебра и эффективная алгебра. Множества могут быть упорядоченные. Множества могут обладать свойством дистанция (при сравнении и нормализации). Эффективная алгебра множеств содержит ряд правил оптимизации выражений языка и функцию контекстно-зависимой сериализации элементов (кодирования/декодирования) [МГУ.матлогика][^1]. Множества могут обладать свойством размерность и образовывать вектора, линейные формы и композиции. Сигма-алгебра множества сопоставляет операциям объединения и пересечения множеств операцию суммирования и обращения чисел при вычислении числовой характеристики - меры. Так вводится, например вероятностностное пространство [МГУ.теорвер], эвклидово пространство, гильбертово пространство, пространство ортонормированных полиномов, пространство суммируемых функций [МГУ.анализ][^2]. 


[^1]: "Колмогоров А.Н., Драгалин А.Г. Математическая логика: ВВЕДЕНИЕ В МАТЕМАТИЧЕСКУЮ ЛОГИКУ. Изд. 6. 2023. 240 с. ISBN 978-5-9519-3878-7."

[^2]: "Колмогоров А.Н., Фомин С.В. Элементы теории функций и функционального анализа Изд. 7. 2023. 572 с. ISBN 978-5-9221-0266-7."

В CBOR представлено мало базовых типов INT, nINT, BSTR, TSTR, TAG, FLOAT/SIMPLE. INT и nINT - сопряженные типы. INT, FLOAT - числове типы. Константы (null, true, false, undefined, NaN, Infinity и пр.) выделяются из кодов SIMPLE(7). Коды ТAG(6) используются для уточнения формата. 

JSON - формат ущербный, его не должно существовать вне схемы кодирования. В нашей сетевой модели нет места для человека, нет необходимости представлять данные в текстовом человеко-читаемом виде, тем более с потерей смысла. Формат JSON не может быть самоописательным, при передаче не может гарантироваться целостность поскольку нет критерия нормализации документа. 

С точки зрения хранения данных в памяти и обработке следует выделить данные, которые лезут в регистры общего назначения и обрабатываются с расширением знака или с насыщением при переполнении. Т.е. определить целые типы можно было бы как SIGNED/UNSIGNED, и разрядностью крантной байту. Тип FLOAT с разным внешним представлением (Float**N**, Binary**N**, Decimal**N**). Далее следуют векторные и тензорные типы составленные из SIGNED|UNSIGNED|FLOAT различной разрядности. Битовые типы, типы заданные перечислением, типы оперирующие последовательностями чисел. Способ упаковки последовательностей может определяться дополнительным тегом. Большие числа произвольной разрядности, для которых тоже надо уметь кодировать сопряженные/обратные числа могут быть представлены типом INT|nINT. Современные требоывания к форматам представления данных для задач ИИ: нужно иметь возможность представлять типы FLOAT пониженной разрядности, вплоть до 2 бит(+1, -1, ноль, NaN). Для этого два числа определяют размерность экспоненты и мантисы. Необходимо составлять из чисел вектора и тензоры. А бинарные строки надо уметь представлять, как числовые последовательности. 

Формат передачи данных может быть сжимаемым, когда речь идет о кодировании числовых последовательностей. Байтовые последовательности могли бы иметь варианты кодирования повторяющихся последовательностей и кодирования сильно разряженных тензорных данных, к которым относятся модели ИИ и диагональные матрицы. Для этого способ кодирования может содержать специальные теги для определения способа кодирования байтовых (выровненных) и битовых (не выровненных) базовых типов (см. [методы сжатия данных типа LZ4](https://github.com/AnatolyGeorgievski/LZJB)). 

### Базовые типы данных

Мы поддерживаем два формата: JSON [[STD90]] и CBOR [[STD94]]. Внутреннее представление (IR, internal representatoin) структур данных позволяет применять структурированные бинарные форматы {ASN.1} типа {BER} и {ВACnet}. Кроме того, мы резервируем возможность представления внутреннего формата в форме статического описания данных на языке Си, т.е. экспорт модели может быть выполнен в структуры языка [Си][C]. А также мы поддерживаем импорт и экспорт модели данных в формате [SAE J1939 DBC](https://github.com/AnatolyGeorgievski/CAN-J1939-DBC), который применяется для моделирования данных в сетях CAN и LIN. Для промежуточного хранения всех этих форматов используется единая типизация,  совместимая по идентификаторам с кодированием основных типов в [BACnet](https://github.com/AnatolyGeorgievski/BACnet). 
```c
enum _ASN_TYPE {
ASN_TYPE_NULL		=0,// пусто
ASN_TYPE_BOOLEAN	=1,// логическая переменная
ASN_TYPE_UNSIGNED	=2,// без знака
ASN_TYPE_INTEGER	=3,// целый со знаком
ASN_TYPE_REAL		=4,// тип соответсвует float
ASN_TYPE_DOUBLE		=5,// тип вещественные числа двойной точности
ASN_TYPE_OCTETS		=6,// байтовые строки
ASN_TYPE_STRING		=7,// символьные строки в кодировке UTF-8 со спец символами \b\t\r\n \"

ASN_TYPE_BIT_STRING	=8,// битовое поле, множество заданное перечислением
ASN_TYPE_ENUMERATED	=9,// идентификаторы состояний, множество заданное перечислением
ASN_TYPE_DATE		=10,// внутреннее представление даты для расписания, может содержать шаблоны
ASN_TYPE_TIME		=11,// внутреннее представление времени для расписания, может содержать шаблоны
ASN_TYPE_OID		=12,// идентификатор объекта, включает идентификатор класса и номер.
};
```
Внутреннее представление элемента структурированных данных:
```c
struct _Node {
    enum _ASN_TYPE type; -- типы ASN_TYPE
    GQuark tag_id;		 -- кварки - строка идентификатора поля заменяется на идентификатор
    union {...} value;
};
```
Объекты (`JSON_OBJECT` или `CBOR_MAP`) и массивы (`JSON_ARRAY` или `CBOR_ARRAY`) представлены односвязными списками `GSList`. Замена и удаление объекта в дереве может сопровождаться заменой элемента данных без измерения элемента списка - это важно для атомарных операций над деревом устройств. Удаленный из дерева устройств объект не содержит списка дочерних элементов и возвращает null. К числу атомарных операций над деревом устройств относится добавление элемента в список, измерение и замена элемента списка. 

При описании структур объектов могут встречаться символьные ссылки на элементы структуры, а также может быть реализовано наследование свойств объектов с использованием символьных ссылок ASN_TYPE_LINK. Символьные ссылки в JSON представлены относительно корня документа или относительно текущей позиции разбора. Символьные ссылки могут содержать хеш-тег на метку документа, заданную идентификатором \$id. Ссылки наследования оформляются как \$ref. Подробнее о ссылках см спецификацию JSON-schema.

[RFC8259][STD90]: / "The JavaScript Object Notation (JSON) Data Interchange Format, 2017" \
[RFC8949][STD94]: / "Concise Binary Object Representation (CBOR), 2020" \
[RFC9052][STD96]: / "CBOR Object Signing and Encryption (COSE): Structures and Process, 2022"

### Расширенная типизация данных 

Типы данных CBOR в языке моделирования данных ([CDDL][RFC8610]) могут обозначаться числами __#7.34__, где за символом hash mark ('#') опционально 
следует числовой идентификатор (0..7) основного типа, за которым вписываются атрибуты типа (доп. информация для кодирования): длина поля или код формата. Перед описанием структуры данных может идти TAG, который определяет формат представления данных. Использование числовой нотации #6.nnn(type) задает код используемого формата, а _type_ уточняет какому основному типу тег может относится. __#6.110(bstr)__ - означает, что тег предшествует байтовой строке, а запись __#6.110(array)__ будет ортносится к массивам. На языке {ASN.1} такую конструкцию следовало бы определить, как CHOICE[110] - выбор формата. 


При описании представления в человеко-читаемый формат, следует ограничть возможность используемых имен. Прежде всего надо сказать что импользуемые имена констант ничего не значат, т.е. можно сопоставить произвольные имена по таблице соотвествия имен, перевести на любой другой язык. Т.е. целостность данных может определяться через бинарное каноническое представление, с нормализованными идентификаторами. Идентификаторы могут сопоставляться по таблице, по порядку контекстных идентификатов. Множество идентификаторв задается перечислением, и в перечислении есть порядковый номер - число. Пространство имен - это одно число - число имен и перечисление текстовых идентификаторов, которые можно транслировать на другой язык без изменения целостности формата. Это контексные идентификаторы. Идентификаторы составленные из имен или позиционных идентификаторов могут быть абсолютными, могут быть относительными. В любом случае идентификатор поля будет представлен как путь - последовательность чисел или последовательность имен полей. Эту последовательность назовем OID - идентификаторы объектов. 

Имя параметра может содержать произвольное число симоволов {"A-Za-z0-9_", "-", "@", ".", "\$"}, начиная с буквы (включая "@", "\_", "\$"),
заканчиваться на букву или число. Использование в именах "-", "." затрудняет перенос в Си (имеется ввиду синтез кода из модели данных). Эти символы заменяются на "\_" при формировании идентификаторов. "$" имеет предназначение - специальных действий, а "@" - мы используем для формирования составных идентификаторов OID. 
Для составных идентификаторов можно было бы использовать ".", но этот разделитель используется в Си. Пространство имен заданное идентификаторами надо превратить в простое перечисление `enum` используя операцию сшивания литералов. Есть еще один споособ записи литералов, который я бы применяется для сравнения и сортировки строк - хеш-таблицы. При сравнении берется хеш-функция от строки и сравнение выполняется в два этапа, сравниваются хеши и если хеш совпал, сравниваются строки. В рабочей системе можно было бы исключить необходимость сравнения строк, сравнивать числовые идентификаторы или хеши от литералов. Например можно сравнивать префиксы состоящие из четырех байт, суффикс и длину текстового идентификатора или потребовать чтобы первые N символов были уникальными.

Кодирование числовых типов данных представляет собой матрицу типов 

| Length ll | uint(0)| sint(1)| real(5)
|:---       |:---    |:---    |:---
| 0         | uint8  | sint8  | binary16 
| 1         | uint16 | sint16 | binary32
| 2         | uint32 | sint32 | binary64
| 3         | uint64 | sint64 | binary128
- Кодирование типизованных массивов выполняется на основе признаков

Кодирование типизованных массивов (векторов) состоит из 24 типов, каждый тип в таблице может иметь представление с порядком следования байт big- и little-endian. Существует конфликт типов внутреннего представления: long double может соответствовать 80 битному формату binary64x. binary16 может быть представлено типом half, _Float16 или _Float32. __FLT_EVAL_METHOD__ -- определяет будет ли параметр преобразован к другому типу см. стандарт Си[[C]]. В языке Си определены типы _Float128 _Float64 и _Float64x для обмена данными и параметры соотвествия машинно зависимых типов `float`, `double`, `long double` и внешних типов  _Float**N**. На разных платформах тип `float` может приравниваться к `double`, а тип  `long double` может приводиться к `double`,  см. `__SIZEOF_LONG_DOUBLE__`. 
Для битовых полей есть свои ограничения `__BITINT_MAXWIDTH__ 65535`, это если тип `BitInt(N)` определен. Типы данных `BitInt` введены в стандарт языка [Си][C] недавно, традиционно для задания битовых полей используются типы `unsigned` и `signed`, которые в CBOR реализуются поверх типов uint и sint путем добавления информции о смещении и длины битового поля. 

Мы используем кодирование типов на основе признаков:
- (s):0 - signed знак
- (b):1 - выравнивание на байт
- (f):2 - тип _FloatN
- (v):3 - векторный тип
- (ll):(4..5) -- выравнивание данных

Признак (b) указывает на использование дополнительной пары параметров _смещение_ и _длина_ битового поля. При этом длина берется в пределелах размера базового типа (ll). 

```c
_TYPE_NULL	        =0x0,// структурный тип
_TYPE_BOOL	        =0x1,// битовый тип
_TYPE_UINT	        =0x2,// целые числа без знака
_TYPE_SINT	        =0x3,// целые числа со знаком
_TYPE_SDNV			=0x4,// идентификаторы с разделителями
_TYPE_REAL	        =0x5,// вещественные числа
_TYPE_BSTR	        =0x6,// кодирование HEX
_TYPE_TSTR	        =0x7,// кодирование UTF8

_TYPE_ARRAY  		=0x8,// Вектор-типизованный массив

_TYPE_UINT8  		=0x02,
_TYPE_UINT16 		=0x12,
_TYPE_UINT32		=0x22,
_TYPE_UINT64		=0x32,

_TYPE_SINT8  		=0x03,
_TYPE_SINT16		=0x13,
_TYPE_SINT32		=0x23,
_TYPE_SINT64		=0x33,

_TYPE_HALF   		=0x05,// _Float16
_TYPE_FLOAT  		=0x15,// _Float32 
_TYPE_DOUBLE		=0x25,// _Float64
_TYPE_FLT128		=0x35,// _Float128. 
```
<details><summary>Преобразование типов FloatN для платформ ARM aarch64 и Intel</summary>

Стандарт языка [Си](C) определяет ряд правил, которым должны следовать компиляторы языка по представлению внешнийх типов.

- тип `long double` приравнивается к _Float64, _Float64x или _Float128 
- тип `float` может приравниваться к _Float32, _Float32x или _Float64
- тип _Float16 может быть преобразован к внутреннему представлению `float`
- cуществует правило представления чисел _Float**N** произвольной разрядности N.

Что касается внутреннего представления целых чисел, тут тоже есть своя схема. Прежде всего типы `short`, `int`, `long int` и `long long int` могут быть представлены на целевой платформе любым разумным размером, с соблюдением правил:
__SIZEOF_SHORT__ &le; __SIZEOF_INT__ &le; __SIZEOF_LONG__ &le; __SIZEOF_LONG_LONG__

Кроме того старндарт [POSIX.1-2024](https://pubs.opengroup.org/onlinepubs/9799919799/) связывает платформо зависимые типы и приводит размер `long` к указателю: ILP32, LP64, ILP64, LPBIG. 

В этих обозначениях под Windows x86_64 поддерживается LLP64 - тип `long long` приравнивается к размеру указателя.

Определение размеров числовых типов для данной платформы может быть получено по запросу:
```sh
# echo -n "" | gcc -dM -E - | grep MANT
```
| определение 			|aarch64| x86_64|
|----------------------:|------:|------:|
|   __LDBL_MANT_DIG__ 	|113	|64
|    __DBL_MANT_DIG__	|53		|53
|    __FLT_MANT_DIG__	|24		|24
| __FLT128_MANT_DIG__ 	|113	|113
| __FLT64X_MANT_DIG__ 	|113	|64
|  __FLT64_MANT_DIG__	|53		|53
| __FLT32X_MANT_DIG__ 	|53		|53
|  __FLT32_MANT_DIG__ 	|24		|24
|  __FLT16_MANT_DIG__ 	|11		|11
| __BFLT16_MANT_DIG__ 	| -		|8
| __DEC128_MANT_DIG__ 	| -		|34
|  __DEC64_MANT_DIG__ 	| -		|16
|  __DEC32_MANT_DIG__ 	| -		|7
| __SIZEOF_LONG_DOUBLE__|16		|16
| __SIZEOF_FLOAT80__ 	| -		|16
| __SIZEOF_DOUBLE__ 	|8		|8
| __SIZEOF_FLOAT__ 		|4		|4
| __SIZEOF_INT__ 		|4		|4
| __SIZEOF_LONG__ 		|8		|4
| __SIZEOF_LONG_LONG__ 	|8		|8
| __SIZEOF_SIZE_T__ 	|8		|8
| __SIZEOF_POINTER__ 	|8		|8
| __SIZEOF_INT128__ 	|16		|16

</details>

- (f) real (вещественные числа со знаком и двоичной экспонентой). fixed (вещественные числа) = с фиксированной точкой. 
- (s) Bool - это знак без поля данных. Null - без знака и без поля данных. sint - знаковый (открицательный) int. 
В том же смысле мы планируем кодировать большие числа (знаковые и беззнаковые) и вектора из данных чисел.
rational Рациональные числа кодируются, как массивы из двух значений, первое число также может быть со знаком или без.
- (e) endian отдельный флаг используется для представления данных во внешнем формате: 1:little-endian, 0:big-endian
- (ll) длина поля данных size = 1<<(f+ll)
Вектора кодируются как типизованные массивы фиксированной длины. 
- (v) Используется типизация массивов достигается путем сочетания флага (v)"array", "ll" и числовых типов. 
Для кодирования типизованных массивов (векторов) в CBOR предусмотрены коды __#6.64..87(array)__.

Для внутреннего представления формата мы определяем ряд структурных типов
```c
_TYPE_OID			=0x0С,// идентификатор ресурса
_TYPE_STRUCT		=0x10,// структура
_TYPE_CHOICE		=0x14,// структура с идентификатором OID
_TYPE_STRUCT_PTR	=0x18,// указатель на структуру данных
_TYPE_LIST			=0x20,// односвязный список
_TYPE_DATA_LIST		=0x24,// список с идентификаторами OID
_TYPE_DATASET		=0x34,// репозиторий с деревом поиска по OID
```
Структурные типы данных образуются от базового типа _SEQ (последовательность параметров), _SET(множества заданные перечислением - списки) и базового типа _SDNV (объект снабжается идентификатором). 

- _TYPE_OID    - ссылка на объект заданая последовательностью числовых идентификатов.
- _TYPE_STRUCT - структурированный тип, описывается списком параметров. 
- _TYPE_LIST   - способ хранения упорядоченного списка объектов типа _SET. 
- _TYPE_CHOICE - выбор структуры по идентификатору ( _OID |_SET )
- _TYPE_DATA_LIST - LIST_OF(CHOICE) и множество форматов кодирования задается перечислением, которое является параметром выбора. 
- _TYPE_DATASET   - SET_OF(DATA) еще один способ хранения списков структурированных объектов, упорядоченным по идентификаторам. Может содрежать сбалансированные деревья BTREE для хранения коллекций с поиском по SDNV. 

Для упорядоченных множеств DATASET определяется функция (сравнения) сортировки. 

Данные способы хранения данных, не являются внешним проявлением, внешнее проявление - структура данных или список, который может иметь числовые или текстовые идентификаторы. Параметром может быть функция сравнения для упорядоченного множества. Список - это форма хранения, множество - это представление. Представление может быть множество SET или множество с идентифкатороами SET-OF. В терминах формата [CBOR] множества представлены базовым типом ARRAY, а множества с идентификаторами - MAP, каждому объекту множества сопоставляется объект. 
Так при обращении к структуре  _TYPE_STRUCT внешним представлением будет MAP. 

### Внешнее представление модели

Ключевые понятия языка моделирования данных мы определяем:
- id    - идентификатор объекта 
- n		- имя ресурса (name)
- ep 	- источник сообщения, адрес на линии (endpoint)
- ins 	- идентификация ресурса (сокр. instnce) по уникальному серийному номеру или адресу
- rt    - идентификатор типа объекта  (сокр. resource type)
- rts   - базовые классы, перечисление типов ресурсов
- sz	- размер для динамического выделения памяти для ресурса данного типа (size)
- ifs   - перечисление интерфейсов (сокр. interface set)
- if[]	- интерфейсы
	- p 	- политики и признаки применимости методов к интерфейсу (policy)
	- ns    - перечисление идентификаторов элементов списка параметров (namespace)
	- eps 	- получатели сообщения (endpoints)
	- sigev - метод уведомления (signal event notify)
- rep[] - внешнее представление representation для каждого интерфейса свой набор элементов
	- type  = расширенный тип данных опеределяет внешний тип через базовый и дополнительные признаки
		- {sign, align, byte_order} -- типизованные вектора
		- tag	= вариант кодирования строк
	- offset   -- смещение элемента данных в памяти относительно начала структуры
	- readOnly -- политики доступа read/write
	- optional -- поле не обязательное
	- mask  = определяет размер и положение битового поля (для типов uint и sint)
	- size  = определяет размер вектора в байах или размер структурированного типа
	- default -- значение по умолчанию для представления параметров optionаl
	- \$ref  = ссылка на определения (\$defs) элементов структурного типа
		- items	= определяет последовательность, вложенную структуру данных (sequence)
		- choice= &{cid: items } приоритетный список вариантов
		- bits  = &{"имя маски": (1..23)} (применяется для представления битовых полей в форме списка)
		- enum  = &{"идентификатор": число} перечисление констант для множеств
		- regexp= регулярное выражение (применяется для текстовых форматов)
		- number= представление числовых типов (uint, sint, real)
			- units = единицы измерения
			- range = диапзон допустимых значений для числовых типов
			- approx= пересчет значений по таблице (b-spline) 

При задании схемы таким образом в формате [JSON.schema](https://json-schema.org/specification) используется разметка, включая наследование фрагментов схемы с перекрестными ссылками внутри документа `$ref` и идентификаторы полей `$id` и хеш-теги `$anchor`. {[JSON.schema](https://json-schema.org/draft/2020-12/json-schema-core), [JSON.validation](https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01)} так и не стал стандартом, так что можно говорить об использовании JSON в качестве внешнего представления схемы, но строгого соответствия нет. Кроме того надо понимать что схема, JSON описывает формат данных внешнего предсавления JSON, и не описывает структуру внутреннего представления. Хорошо стандартизированным оказался язык [CDDL], который принято использовать для описания структур данных в формате CBOR. CDDL описывает списки трех видов (MAP, ARRAY, SEQUENCE) и признаки (optional, multiple):

| CDDL  | Remark                                    
|-------|-------------------------------------------
| "="   | /= and //= are abbreviations              
| "//"  | prioritized choice 
| "/"   | prioritized choice, limited to types only 
| "?" P | zero or one  (optional)
| "\*" P| zero or more (optional, multiple)
| "+" P | one or more  (multiple)
| A, B  | sequence  
- правила языка описания данных [CDDL][RFC8610] требуют, чтобы внутренний формат имел соответствующие признаки. 

| Name     | Documentation
|----------|--------------
| .oid	   | [RFC9090]
| .size    | [RFC8610]      
| .bits    | [RFC8610]      
| .regexp  | [RFC8610]      
| .cbor    | [RFC8610]      
| .cborseq | [RFC8610]      
| .sdnv	   | [RFC9090]
| .sdnvseq | [RFC9090]
| .within  | [RFC8610]      
| .and     | [RFC8610]      
| .lt      | [RFC8610]      
| .le      | [RFC8610]      
| .gt      | [RFC8610]      
| .ge      | [RFC8610]      
| .eq      | [RFC8610]      
| .ne      | [RFC8610]      
| .default | [RFC8610]      
- Таблица операторов языка

Для внешнего представления данных (визуализации) в модель нужно добавить параметры метода представления данных, вроде интерполяции и коэффициентов пересчета, размерности физических величин, периодичность опроса и выбор режима отображения, задани калибровочных параметров и паспортных данных, комментариев и пр. атрибутов. Если ресурс поддерживает интерфейс датчика с паспортом, можно получить паспорт отдельным документом, обратившись по ссылке `uri`. 

Все это составляет схему кодирования и схему представления данных - два подмножества модели данных. Нас интересует описание схемы кодирования данных в приложении протокола управления и сбора данных с учетом поддерживаемх методов. 

Набор методов - это интерфейс. Можно определить набор поддерживаемых интерфейсов. Множество поддерживаемых интерфейсов определяет состав программного обесепчения устройства и полноту модели данных. 

Порядок обработки данных для представления в протоколе включает создание промежуточного представления для кодирования из внутреннего представления и сериализация по правилам выбранного формата на основе структур вроде дерева. 

Промежуточное структурированное представление исопльзует упрощенную типизацию JSON: \
{null(0)|bool(1)|uint(2)|sint(3)|float(5)|tstr(7)}

а также структурные типы используемые при кодировании: \
{oid|array|object|ref} \
и представление, 
которое определяет также и правила внешнего кодировния текстовых строк.

Кодирование строк предполагается одним из форматов, заданных схемой и используемых в стандарте CoAP. В наших задачах предполагается использование форматов `utf-8`, `base16`, `base64url` для представления в JSON. Кроме того, есть требование самого формата JSON - представление чисел возможно с использованием строк, в частности, когда длина числа превосходит 53 бита (длина мантиссы _Float64), то число будет представлено строкой. В наших задачах, если число приходит в форме строки, то предполагается декодирование HEX. Для байтовых строк при декодировании больших чисел - декодирование HEX. Для векторных типов (типизованных массивов) - кодирование выполняется байтовыми строками (HEX). Типизованные массивы (вектора) и структурированные данные могут быть представлены в формате байтовой строки _CBOR_SEC - последовательность кодов CBOR.

| Тип кодирования      	| type  | Tag   | Источник
|:--					|:--	|:--	|:--
|_TYPE_TIME_DATETIME	|0x31  	|#6.00 	|[[RFC8949]] 3.4.1. Standard Date/Time String
|_TYPE_TIME_UNIXTIME	|0x21  	|#6.01  |[[RFC8949]] 3.4.2. Epoch-Based Date/Time
|_TYPE_BSTR_BIGNUM		|0x16   |#6.02 	|-- число фиксированного размера BE
|_TYPE_BSTR_BIGNUM_N	|0x16   |#6.03 	|-- сопряженное число
|_TYPE_BSTR_SDNV		|0x04	| -		|[[RFC9090]]
|_TYPE_BSTR_CBOR		|0x26   |#6.24 	|-- данные в бинарном структурированном формате
|_TYPE_BSTR_CBOR_CWT	|		|#6.61	|[[RFC]]
|_TYPE_BSTR_CBOR_SEQ	|0x36   |#6.63	|[[RFC8742]]
|_TYPE_TSTR_UTF8		|0x07   | -		|
|_TYPE_TSTR_???			|0x17	|#6.31 	| (резерв)
|_TYPE_TSTR_URI			|0x27	|#6.32
|_TYPE_TSTR_BASE64U	 	|0x37	|#6.33
|_TYPE_TSTR_BASE64 		|0x47 	|#6.34
|_TYPE_TSTR_REGEXP		|0x57	|#6.35
|_TYPE_TSTR_MIME		|0x67	|#6.36
|_TYPE_TSTR_UUID		|0x77 	|#6.37	|[[RFC9562]]
|_TYPE_ARRAY_MULTI_DIM	|0x08	|#6.40	|[[RFC8746]] - двумерный массив (размерность uint 15бит x2 или 10бит x3)
|_TYPE_ARRAY_STRUCT		|0x28	|#6.41  | массив структурированных данных
|_TYPE_ARRAY_BE_UINT8   |0x0A   |#6.64	|[[RFC8746]]
|_TYPE_ARRAY_BE_UINT16  |0x1A   |#6.65	
|_TYPE_ARRAY_BE_UINT32  |0x2A   |#6.66	
|_TYPE_ARRAY_BE_UINT64  |0x3A   |#6.67	
|_TYPE_ARRAY_LE_UINT8C  |0x4A   |#6.68	|[[RFC8746]] - (Clamped) с насыщением 
|_TYPE_ARRAY_LE_UINT16  |0x5A   |#6.69	
|_TYPE_ARRAY_LE_UINT32  |0x6A   |#6.70	
|_TYPE_ARRAY_LE_UINT64  |0x7A   |#6.71	
|_TYPE_ARRAY_BE_SINT8   |0x0B   |#6.72	|[[RFC8746]]
|_TYPE_ARRAY_BE_SINT16  |0x1B   |#6.73	
|_TYPE_ARRAY_BE_SINT32  |0x2B   |#6.74	
|_TYPE_ARRAY_BE_SINT64  |0x3B   |#6.75	
|_TYPE_ARRAY_LE_SINT8C  |0x4B   |#6.76	|[[RFC8746]]
|_TYPE_ARRAY_LE_SINT16  |0x5B   |#6.77	
|_TYPE_ARRAY_LE_SINT32  |0x6B   |#6.78	
|_TYPE_ARRAY_LE_SINT64  |0x7B   |#6.79	
|_TYPE_ARRAY_BE_FLT16   |0x0D   |#6.80	|[[RFC8746]]
|_TYPE_ARRAY_BE_FLT32   |0x1D   |#6.81	
|_TYPE_ARRAY_BE_FLT64   |0x2D   |#6.82	
|_TYPE_ARRAY_BE_FLT128  |0x3D   |#6.83	
|_TYPE_ARRAY_LE_FLT16   |0x4D   |#6.84	|[[RFC8746]]
|_TYPE_ARRAY_LE_FLT32   |0x5D   |#6.85	
|_TYPE_ARRAY_LE_FLT64   |0x6D   |#6.86	
|_TYPE_ARRAY_LE_FLT128  |0x7D   |#6.87	|(хранение м.б. 80-бит `Float64x` или `Float64`)

Данные правила кодирования позволяют выполнять однозначное преобразование из JSON в CBOR за счет расширенной типизации без явного использования схем, основываясь на однозначном определении метода кодирования из кода typе. 

[IANA.cbor-tags]: <https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml> "Concise Binary Object Representation (CBOR) Tags"
[RFC.cbor-tags]: <https://datatracker.ietf.org/doc/draft-bormann-cbor-notable-tags> "Notable CBOR Tags"

Ряд тегов кодирования может относиться к структурным типам или базовым
| Тип кодирования      	| Tag   | Источник
|:---					|:--- 	|:---
|_TYPE_ANY_BASE64U		|#6.21
|_TYPE_ANY_BASE64		|#6.22
|_TYPE_ANY_BASE16		|#6.23
|_TYPE_ANY_LANGUAGE		|#6.38	|[RFC9290]
|_TYPE_ANY_PRIMARY_KEY	|#6.39
|_TAG_SDNV_SEQ			|#6.110	|[RFC9090] (BER encoding); SDNV [RFC6256] sequence
|_TAG_BER				|#6.111	|[RFC9090] (BER encoding)		
|_TAG_BER_RELATIVE		|#6.112	|[RFC9090] (BER encoding), relative to `1.3.6.1.4.1`

Правила кодирования SDNV распространяются на байтовые строки в массивах и идентификаторах полей. 
При этом внешнее представление может быть в числовом типе.

Кодирование полей в каждом из форматов (CAN, CBOR, JSON) будет иметь свои особенности. Особенностью CAN DBC является обязательная битовая упаковка знаковых и беззнаковых типов данных и представление вещественных чисел в виде целых чисел, использование признака порядка следования байт. Особенность CBOR - добавляются теги кодирования полей. Особенность JSON кодирование строк определяется схемой. 

Совместить правил кодирования в одной схеме формата документа кажется невозможной задачей.  

### Моделирование данных датчиков в сетях сбора данных ###

{Надо моделированию датчиков в сетях сенсоров посвятить тему}


Язык моделирования данных нужен, чтобы синтезировать статическое описание структур данных на языке Си и схемы документов для каждого из форматов внешнего представления.

Со временем мы бы хотели отказаться от возможности кодирования данных в JSON. Предача данных для датчиков и исполнительных устройств в сетех CAN, UART, предполагается только в формате CBOR. 
Для представления данных используется преобразование CBOR-to-JSON с использованием схем представления JSON.  

Внутреннее представление данных должно быть ориентировано прежде всего на бинарное кодирование данных и икапсуляцию данных в сетевые протоколы. 
(внешнее представление)JSON<-(внутреннее представление)->CBOR->передача данных по сети->CoAP+TCP<-> маршрутизация запросов-> представление CAN<->(внутреннее представление)Датчик.
Внутреннее предсталение данных для последующей передачи на линию CAN со стороны логгера должно поддерживать 64 битные операции. Со стороны датчика предполагается поддержка модели данных LP32. В микроконтроллерах (датчик, оконечное устрйоство) внуреннее представление типов float приводится и к типу uint32_t. Для промежуточного представления используется разрядность по крайней мере 64 бита и double. 


## Характеристики протокола CoAP ##

Методы протокола бывают нескольких типов: **CREATE, RETRIEVE, UPDATE, DELETE, and NOTIFY (C,R,U,D,N)**. Терминология вводится в соответствии с протоколами [CoAP] и спецификацией [OCF][OCF.spec]. В протоколах используется образначения совместимые с HTTP RESTful: RETRIEVE(GET), UPDATE(PUT), CREATE(POST), DELETE, NOTIFY. Протокол оперирует понятием "ресурс". 

Для передачи больших объемов данных предусмотрены методы блочной пересылки данных с подтверждением и возобновлением обмена. При этом номера блоков и подтверждения получения передаются в шапке протокола, как опции. 

_Трансляция адресов устройств_ [развитие] 
Маршрутизация запросов на основе виртуальных идентификаторов устройств. В протоколе определяются устройства или конечные потребители или точки назначения запросов, как "ep" (endpoint). Вместо явного указания адреса устройства могут использоваться уникальные идентификаторы устройств или уникальные имена устройств.

_Кеширование запросов_ [развитие] 
Устройство сбора данных может собирать данные на линиях последовательной передачи данных (CAN, RS485) и представлять, как собственную коллекцию данных. Кеширование основано на механизме ETag, вместе с ответом передается тег, по которому (сервис) может судить произошло ли изменение полей объекта. 

_Маршрутизация запросов_ [развитие] 
В протоколе CoAP предусмотрена функция Proxy, для обращения во внутренние сети.

_Перенаправление запросов_ [развитие] 
Перенаправление выполняется с использованием встроенных опций Location, 

_Структурированное представление_ 
Корень директории /dev - означает "это устройство". Объектные идентификаторы этого устройства располагаются в диерктории /dev. Для структурированного представления данных применяются объекты типа коллекция dir@ и объекты типа lnk@ (символьная ссылка). Коллекции могут содержать ссылки на другие объекты. Коллекция dir@0 ссылается на корень '/'. 

_Распознавание структуры сети и оборудования_
Порядок работы с устройством:
авторизация, идентификация системы, запрос перечня поддерживаемых методов команда dev.info.

### Кодирование команд в URI ###

URI состоит из пути uri_path и параметров запроса uri_query. пути и параметры запросов URI используются для маршрутизации запросов в рамках протоколов HTTP RESTful, MQTT и CoAP.
```
<uri_schema> '://' <uri_host> ':' <uri_port> '/' <uri_path> '?' <uri_query> '#'<hashtag>
```

Каждая компонента пути имеет свою структуру и разделители полей. В протоколе CoAP все компоненты передаются в виде списка опций в составе заголовка пакета в разобранном виде. 
_uri_path - путь к ресурсу, состоит из имен коллекций, которые определены на данном устройстве. Путь разрешается относительно префикса сервера. Мы предполгаем множество серверов на одном адресе, которые различаются по префиксу пути. Префиксы специального назначения могут начинаться с '.', например ".well-known". Суффикс пути (последний элемент списка uri_path) используется для доступа к методу объекта. Методы состоят из двух частей: тип ресурса и тип метода. dev.set_params состоит из метода "set_params", а класс метода адресуется параметром запроса, например "rt=dev".
Минимальный набор интерфейсов "Ресурс", "Устройство", "Датчик". Данная концепция развивается в проекте Open Connectivity Foundation (OCF)[[OCF.spec]]. Концепция [OCF] выглядит громоздко в моделях из-за длинных идентификаторов заданных в форме URI, мы не планируем их применять, многие концепции моделирования данных и распознавания оборудования могут быть заимствованы. Сам формат OpenAPI 2.0 для представления схем, основанный на [JSON.schema][], достоин применения при использование компактных текстовых идентификаторов OID или числовых последовательностей в форме байтовой строки _TYPE_BSTR_SDNV. 

Запросы протоколов в модели OCF СRUDN таких, как [HTTP] [RESTful] и [CoAP] на прикладном уровне содержат опции запроса в строке URI.

_uri_query_ состоит из пар `key=value`, разделенных знаком '&'.
Стандартные ключи определенные в [[RFC6690]] включают: 
+ if - интерфейс обработки запросов
+ id - перечисление идентификаторов ресурса, мы используем текстовые идентификаторы OID и [SDNV];
+ di - идентификатор устройства
+ ins- уникальный номер ресурса (instance) в коллекции или в списке
+ n  - имя объекта (name), имя ресурса должно быть уникальное для поиска по имени;
+ rt - имя тип ресурса (type);
+ sz - размер фрагмента данных.
+ range - перечисление {min..max}
+ step  - шаг для перебора элементов
+ precision - точность (значащих цифр)
+ units - физические величины

Типы ключей могут быть:
- uint - целое число без знака;
- sint - целое со знаком;
- tstr - текстовый идентификатор;
- oid - идентификатор объекта, разделитель SDNV '.';
- seq(type) - перечисление чисел через разделитель ','. 

Для каждого _метода_ определен список обязательных параметров запроса `required`. 
Например, при обращениик  элементу списка использутся идентифкатор объекта OID и номер позиции в списке. При обращении к массиву должен задаватья номер параметра и позиция в массиве. Таким образом чтобы адресовать в одном запросе множество параметров нужно чтобы каждй такой параметр кодировался последовательностью _TYPE_BSTR_SDNV.

Для описания пути к параметру объекта используются числовые последовательности основанные на позиционных номерах, заданных перечислением идентификаторов полей в модели. При обращении к ресурсу последовательность идентификатов задается параметром `id`

В параметры запроса попадают те параметры, которые не являются свойством объекта, но являются свойством протокола обмена. Существует ряд свойств, которые наследуются из понятия "Ресурс", такие как: идентификатор объекта `id`, имя `n` и список имен параметров объекта `ns`. Список параметров `ns` позволяет получить перечень текстовых идентификаторов, используемых в запросах. Список параметров возвращается в составе опций протокола и используется при кодировании CBOR. 

Распознавание полей объекта выполняется по списку параметров `rts` -- запрос выполняется по типу ресурса `rt` и списку обязательных полей ресурса "rts-m". key="имя-параметра". Представление объекта `rep` (representation) - это и есть заполненный список параметров. Если в запросе отсутствует список параметров, возвращается ответ по спику `rts-m` (mandatory).

При описании метода прикладного протокола используется запись вида method:"класс.метод". В протоколе CoAP класс передается в поле типа ресурса uri_query="rt=класс", метод - в составе пути uri_path="метод". 

При составлении пути для протокола [MQTT] модель [OCF] предлагает к URI добавлять букву метода протокола **CREATE, RETRIEVE, UPDATE, DELETE, and NOTIFY (C,R,U,D,N)**. Таким образом составление пути для MQTT будет включать:
- /{префикс}/{устройсво}/{метод}?id={OID}/R   -- запрос к ресурса по идентификатору, OID включает класс
- /{префикс}/{устройсво}/{метод}?rt={класс}/R -- запрос параметров данного класса, возвращает схему `rts` и `rts-m`.
- /{префикс}/{устройсво}/{метод}?rt={класс}/C -- создание объекта данного класса
- /{префикс}/{устройсво}/{метод}/N			-- уведомления от устройства 
- /{префикс}/{метод}/N						-- уведомления для всех устройств
При составлении пути используется минимальный достаточный набор полей запроса. Добавление букв (C,R,U,D,N) не является обязательным, если идентификация типа сообщения может быть выполнена по имени метода.

Предназначение MQTT - публикация статистики для отображения в dashboard, удаленное управление с использованием подписки, процедуры автоматического распознавания обрудования. 

В модели OCF объекты поддерживают ряд стандартных интерфейсов. Один из таких интерфейсов - активация оборудования и активация элементов списка ресурсов. Элементы списка ресурсов могут иметь приоритет "pri" и параметр задержки, "lat" (latency). Активация предполагает некоторую диаграмму состояний объекта включая: инициализацию, работу, ожидание, паузу, блокировку, завершение,  сохранение настроек, повторный запуск. С такими объектами ассоциируется процесс, идентификатор треда "ins" (instance). Мы предполагаем наличие механизма основанного на флагах сигналов.
```js
{method:"dev.select" oid:"pool@0"} -- выбрать пул как основной,
{method:"dev.select" oid:"psu@1"}  -- выбрать БП  как основной,
{id:7, method:"get_params", obs:1, oid:"psu@1", max_age:60, params:[...]} -- список имен параметров объекта, которые отсылаются по подписке.
```
Подписка действует некоторое время TTL (Max-Age), потом прекращается. Команда подписки включает некоторый уникальный идентификатор подписки, который ассоциирован с тредом, получателем сообщений типа publish или NOTIFY. Ассоциация работает через привязку идентификатора сообщения (токена) к треду pid. Номер треда может входить в состав токена. 

В протоколе CoAP присутсвует подписка, Команда GET c опцией Observe=1 вызывает подписку на периодические уведомления об изменении параметра.
```js
{id:1, method:"pool.add_list", oid:"pool@1" params:{...}}
```
Метод протокола преобразуется в параметры запроса CoAP как 
```
token:1, 
uri_path:add_list, 
uri_query:id=pool@1, 
uri_query:rt=pool, 
content-format: application/json 
```
и вложенный пакет с текстовым представлением объекта params в формате JSON. 

Отклик response:
```js
{id:1, result:true, error: null } -- короткий ответ
```
нормальное завершение
```js
{id:1, result:false, error: "4.05 Method Not Allowed" } -- сообщение об ошибке
```
Результаты операций передаются кодами. 

При нормальном завершении коды завещения 2.nn (Success):
| Code | Description                  | Reference 
|------|------------------------------|-----------
| 2.01 | Created                      | [RFC7252] 
| 2.02 | Deleted                      | [RFC7252] 
| 2.03 | Valid                        | [RFC7252] 
| 2.04 | Changed                      | [RFC7252] 
| 2.05 | Content                      | [RFC7252] 
| 2.31 | Continue                     | [RFC7959] 
| 4.00 | Bad Request                  | [RFC7252] 
| 4.01 | Unauthorized                 | [RFC7252] 
| 4.02 | Bad Option                   | [RFC7252] 
| 4.03 | Forbidden                    | [RFC7252] 
| 4.04 | Not Found                    | [RFC7252] 
| 4.05 | Method Not Allowed           | [RFC7252] 
| 4.06 | Not Acceptable               | [RFC7252] 
| 4.08 | Request Entity Incomplete    | [RFC7959] 
| 4.12 | Precondition Failed          | [RFC7252] 
| 4.13 | Request Entity Too Large     | [RFC7252] 
| 4.15 | Unsupported Content-Format   | [RFC7252] 
| 5.00 | Internal Server Error        | [RFC7252] 
| 5.01 | Not Implemented              | [RFC7252] 
| 5.02 | Bad Gateway                  | [RFC7252] 
| 5.03 | Service Unavailable          | [RFC7252] 
| 5.04 | Gateway Timeout              | [RFC7252] 
| 5.05 | Proxying Not Supported       | [RFC7252] 

Коды ошибок в запросах клиента 4.00 , и коды ошибок сервера 5.00 <coap.h> возвращают запись result:false и текстовое сообщение в поле "error".

```js
{id:3, method:"psu.set_params", oid:"psu@1", params:{...}}
```

```js
{id:4, method:"psu.get_params", oid:"psu@1", params:[...]}
```
Поле параметров "params" содержит перечисление имен или числовых идентификаторов параметров. 

```js
{id:5, method:"psu.info", oid:"psu@1"}
```
Метод равносилен команде get_params с предопределенным перечнем параметров. 

### Опции протокола ###

Стандартный набор опций протокола CoAP включает:
*   o  Accept		 -- список поддерживаемых форматов (передается однократно)
*   o  Content-Format -- тип данных application/json, application/cbor и др.
*   o  Location-Path  -- перенаправление запроса 
*   o  Location-Query -- перенаправление запроса
*   o  Max-Age		 -- время атуальности подписки и время хранения параметров сессии
*   o  Proxy-Uri	 -- путь с использованием прокси-сервера
*   o  Proxy-Scheme	 -- схема прокси протокола coap, coaps, coap+tcp, coap+ws и др.
*   o  Uri-Host		 -- хост назначения сообщения
*   o  Uri-Path		 -- путь сообщения
*   o  Uri-Port		 -- TCP порт (5683) 
*   o  Uri-Query	 -- параметры запроса такие как id, if, n, rt.
*   o  ETag			 -- тег кеширования запросов (1..8) байт, формирует сервер
*   o  If-Match		 -- запрос с копией тега кеширования, ответ передается, если один из тегов match совпадает c etag.
*   o  If-None-Match -- флаг условия использования тега кеширования, ответ передается если ни один тег match не совпал. 
*   o  Observe		 -- передается в составе сообщений NOTIFY по подписке [[RFC7641]]

### Расширенные токены ###

Токены предназначены для отслеживания и привязки сообщений. НО токены могут использоваться и для управления безопаснотью и поддержки сессии. Мы предполагаем использование коротких токенов в один байт (0..255) для привязки к запросу. В протоколе CoAP существует возможность устанавливать размер токена (0..8) байт и более[[RFC8974]]. Мы поддерживаем расширенные токены до 8 байт и предполагаем передачу в составе токена флагов состояния обмена и привязку к сессии и ключам безопасности. Передача вспомогательной информации в составе токена позволяет выполнить шифрование шапки сообщения. В протоколе CoAP вводится понятие Stateless клиент - разбор пакетов может выполняться без хранения промежуточной информации только на основе данных из шапки запроса. Состояние обмена возрващается клиенту в составе токена и набора опций. 
   
Сервер не создает своих токенов. Сообщения сервера сигнальные #7.xx передаются без токенов, а сообщения уведомлений типа NOTIFY используют токен клиента при запросе GET.Observe=1. В остальных случаях сервер в оклике повторяет токен клиента. Сообщения NOTIFY инициированные сервером не используют токены, но используют метку времени CLOCK_REALTIME в опции NOTIFY.Observe. Подробнее функционал NOTIFY с опцией Observe изложен в рекомендациях [RFC7641].

### Форматы сообщений ###

Мы поддерживаем два основных формата, которые взаимозаменяемы: CBOR и JSON и являются стандартами сетевых технологий. Формат CBOR бинарный структурированный, JSON - текстовый. Для представления и валидации обоих форматов нужна база схем, предполагается использование схем вида JSON-schema, YANG, CDDL или подобных им. Кроме того нужен метод привязки идентификатор и человеко-читаемого имени параметра и описание представления объектов в человеко-читаемом виде. 

Существует третий формат данных, который используется при кодировании опций CoAP. Формат ориентирован на передачу коротких текстовых и числовых параметров key=value, таких как uri_query или uri_path, в поле key передается идентификатор-число. Организация формата - ключи должны быть упорядочены по возрастанию идентификатора ключа. Правила кодирования позволяют удобно кодировать и быстро выполнять разбор данных при множественном повторе ключа, таким образом можно передавать и хранить списки, эффективно выполнять привязку идентификаторов и имен полей. Этот формат можно составлять руками:
"\x25value\x07invalid\x18encodded"
При распаковке используется делта-кодирование идентификаторов полей: старшие четыре бита содержат приращение номера ключа, а младшие - длину поля (0..12). Значение 13 используется для расширения длины поля (13..255). \
key02="value"\
key02="invalid"\
key03="encodded"

Разбор полей выглядит просто:
```c 
unsigned key=0;
do {
	key  += _delta (option); -- option[0]>>4
	len   = _length(option); -- option[1]&15
	value = _value (option); -- option + 1;
	. . .
	option= _next(option);   -- option = value+len;
} while ();
```
Разбор завершается, если найден символ завершения 0xFF или достигнут конец записи. Разбор перечисления выплняется с условием, что ключ не меняется: `do{. . .} while(delta==0);`

Кодирование полей определяется типом (схемой), допустимы типы `bstr`, `tstr`, `uint`, `empty`. Декодирование строк выполняется без обработки, кодирование чисел - использует префикс 0x для шестнадцатеричных констант.

[IANA.core-parameters]: <https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats>

### 1. Команды пула ###
```
pool.add_list -- создать объект со свойствами, 
pool.remove_list -- удалить объект из списка, 
pool.info -- информация о пуле, 
pool.stat -- статистика пула, 
pool.set_params -- настройка параметров пула
pool.get_params -- запрос параметров пула
```

### 2. Команды устройства ###
```
dev.info
dev.stat
dev.set_params oid params:[]
dev.get_params params:[]
```

### 3. Команды хешплаты ###

Хеш-плата это множество вычислительных узлов (процессоров) с последовательной адресацией организованных в виде 2D матрицы или цепочки. Процессоры могут быть многоядерными (например, 128 ядер). Все процессоры считают одно задание `job` с разным смещением. Если решение найдено, хеш-плата генерирует сообщение типа nonce, включая ссылку на задание job_id и параметры расчета, при котором найдено решение. Хеш-плата экспортирует интерфейс env датчиков окружения, интерфейс системы управления электропитанием и энергопотреблением. 

```
brd.info -- информация о хеш-плате, 
brd.stat -- статистика платы, 
brd.set_params -- настройка параметров платы
brd.get_params -- запрос параметров платы
```


```js
{id:2, method:"brd.get_params", oid:"brd@0", params:[...] }
{id:2, result:true, error: null, params:{...}}
```

3.1 Команды управления процессом. HB cmd {stop, run, probe, save}
```js
{id:3, method:"hb.state", oid:"brd@0", params:{"cmd":"run"} }
```
3.2 Динамическая подстройка частоты
```js 
{id:32, method:"hb.set_freq" , oid:"brd@1", params:{"freq":450.5, "adjust":[+1,-1,0,-2...]} }
```
freq обязательный параметр, а таблица настроек не обязательный adjust, при активации команды dev.save выполняется сохранени файла конфигурации,

Некоторые параметры устройства являются командными, т.е. обращение к параметру вызывает действие по обработке данных. 

## Команды управления состоянием объектов ##
```js
{id:3, method:"brd.cmd", oid:"brd@0", params:{"cmd":"run"} }
```
1. Команды пула: 		    "save_config","stop","run"
3. Команды хешплаты: 		"save_config","stop","run","probe","restart"
4. Команды блока питания:  	"save_config","stop","run","probe","restart"
5. Команды устройству: 		"save_config","stop","run"

Каждый объект в системе имеет свойства: 
```c
struct _Object {
	uint32_t 	oid;
	const char*	name;
	const ObjectClass_t* cl;
	sigset_t signals; // флаги управления, 
};
```
часть этих флагов зарезервирована под команды: {0:run, 1:stop, 2:save, 3:break}. Флаги обрабатываются последовательно 

+ `probe  = run|break`, сначала run, потом выполняется заверщение в ближайшей точке останова. 
+ `restart=stop|run`, сначала завершается потом стартует заново

Команда "save" -- конфигурация сохраняется из "running_config" в "startup_config". Если команда применяется к устрйоству, то конфигурация сохраняется в энергонезависимую память (в файл конфигурации, на флеш или в eeprom). Если команда  относится к объекту, то сохраняется конфигурация объекта в startup_config. 
Команды "probe" - выполняет команду run и проводят инициализацию устройства до момента идентификации оборудования и определения параметров и завершают работу. 
Команда restart останавливает работу и запускает заново. Команда равносильна установки флагов "stop" и "run" одновременно. 

Модель объекта надо понимать следующим образом. Каждому такому объекту соответствует тред, который может быть в одном из состояний: running, stopped, idle ... У треда три функции: инициализация, работа, финализация. Команда stop завершает тред. Команда run запускает тред из состояния stopped, запуск включет инициализацию и загрузку конфигурацию sturtup_config и переход к исполнению, если установлен флаг break, то сразу после инициализации выполняется финализация, если установлен флаг save, то после завершения работы, настройки сохраняются.

## Подписка на журнал, на события или на уведомления ##

Устройство включает методы сбора сообщений через журнал сообщений, сообщения классифицируются по уровням (saverity&priority): _INFO, _DEBUG, _MESSAGE, _ERROR, _WARNING, _CRITICAL, _FATAL и относятся к доменам публикации. Домены задаются строками, относительными путями типа "brd/hashrate" или "dev/log". Публикация выполняется на сервер МQTT или на широковещательный адрес локальной сети (мультикаст, опция планруется к реализации).

Команда подписки включает пару параметров, например: .saverity="info", .domain="dev/" и 
Список доментов публикации потоков сообщений можно получить через опрос системы "dev.info", параметр domain:[...] содержит перечень доменов публикации сообщений. Параметр log:[]содержит перечень доменов, на которые оформлена подписка. 

Внутреннее представление сообщения в журнал события - текстовая строка в формате json. 

Подписка на события event_notify или cov_notify должна включать идентификатор треда получателя уведомления (pid). Идентификатор треда - целое число без знака.


## Моделироване данных в сетях последовательной передачи данных ##

Способ описания данных прежний. Мы за основу берем способ моделирования данных для линий CAN предложенный форматом [DBC]

2. Пространство имен
<pre>
$version : 
"namespace": [...] перечисление имен идентификаторов верхнего уровня
"bus"    : -- характеристики линии сбора данных
"unit"   : -- устройство, характеристики устройства как участника обмена
"object" : -- объект, состоит из параметров
"signal" : -- элемент структуры данных
</pre>

3. Определение линии, скорости передачи
```js
"bus": {"baudrate":[BTR1, BTR2, ...]} ; 
```
BTR1 = unsigned_int ;
BTR2 = unsigned_int ;

4. Определение узла, перечисление узлов в сети
```js
"unit":[...] ; -- перечень узлов, которые являются получателем сообщения
```

5. Определение кадра
```
messages = {message}+ ;
message = 'BO_' message_id message_name ':' message_size transmitter {signal}+;
message_id = unsigned_int ;
transmitter = node_name | 'Vector_XXX' ;
```
Кадр сообщения состоят из сигналов (полей). Определен источник сообщений или undefined.

6. Определение сигнала

Описание в формате SAE J1939 DBC применяется в автомобильной промышленности для сбора данных и представления данных в логгере [DBC]:
```
signal = 'SG_' signal_name multiplexor_id ':' start_bit '|'
	signal_size '@' byte_order value_type (factor ',' offset ')'
	'[' minimum '|' maximum ']' unit receiver { ',' receiver } ; 
signal_name = C_identifier ;
multiplexor_id = ' ' | 'M' | m multiplexer_switch_value;
byte_order = '0' | '1' ; (* 0-little endian, 1-big endian *)
value_type = '+' | '-' ; (* + unsigned, - signed *)
unit = char_string ;
receiver = node_name | 'Vector_XXX' ;
```

Существуют отличия внутреннего представления от DBC, поскольку формат DBC определяет упакованную структуру полей без выравнивания на байт. В DBC все типы приводятся к знаковому или беззнаковому типу {signed, unsigned} размером до 64 бит. Для полей определяется порядок следования байт. Поля могут быть мультиплексируемыми, в тех случаях, когда не удаетя передать одним кадром. 

Кроме того, указываются дополнительные параметры связанные с представлением данных. В частности, отображение данных предполагается в нескольких вариантах, основанных на модели представления: линейная интерполяция. Таблица значений с равным шагом, на интервале интерполяция B-сплайном. 
Таблица значений заданных на итервале множеством пар значений (x,y), интерполяция Лагранжа. 
Значения заданные, как битовые поля имеют списки имен полей. Значения заданные типом _ENUMERATED - перечень имен состояний.  

 
## Безопасность ##

Права чтения. Все параметры имеют предопределенные маски полей и признаки readOnly и Оptional. В модели OCF присутствует параметр "p":(policy) который определяет правила доступа к ресурсу. Доступ к объектам может быть ограничен на основе политик безопасности.


|Tag|	cose-type		| Data Item		| Semantics
|---|-------------------|---------------|------------------------
|98 |	cose-sign		| COSE_Sign		| COSE Signed Data Object
|18 |	cose-sign1		| COSE_Sign1	| COSE Single Signer Data Object
|96 |	cose-encrypt	| COSE_Encrypt	| COSE Encrypted Data Object
|16 |	cose-encrypt0	| COSE_Encrypt0	| COSE Single Recipient Encrypted Data Object
|97 |	cose-mac		| COSE_Mac		| COSE MACed Data Object
|17 |	cose-mac0		| COSE_Mac0		| COSE Mac w/o Recipients Object

Защита данных в CoAP может включть шифрование тела пакета и опций (части опций), часть опций необходимых для маршрутизации могут передаваться в открытом виде. 

### Представление сертификатов X.509 ###

Важным этапом является переход с сертификатов X.509, CMS на структурированные данные в формате CBOR. X.509 использует кодирование ASN.1 BER [[X.690]]. BER - бинарный структурированный формат с длинными идентификаторами полей, который занимают много места в сертификатах. [RFC9090] Предлагает прямой способ представления OID с сохранением способа кодирования идентификаторов и кодирование структурированных данных с использованием правил CBOR. Вместе с тем мы можем использовать способ кодирования идентификаторв принятый для OID для кодирования наших идентификаторов. Способ кодирования числовых идентификатов основан на рекомендациях [[RFC6256]], Self-Delimiting Numeric Values (SDNVs).


### Национальная криптография ###

Мы ориентируемся на поддержку отечественных протоколов  (помимо стандартных американских шифров и методов), планируем шифрование методом ГОСТ Magma [[TC26.Magma]] с учетом рекомендаций построения протоколов CRISP и сервиса Обмена ключевой информацией для поддержки [[TC26.CRISP]]. 

Шифр Magma имеет комапактную реализацию и может быть представлен в контроллерах с ограничнными ресурсами. 


## Инфраструктура безопасности IIoT устройств ##

Состоит из сервисов
Сервис ключей обрабатывает запросы всех участников обмена и раздает ключи шифрования, конфигурационные файлы и файлы обновления встроенного ПО. 
Сервис CoAP over TCP обрабатывает запросы
Сервис MQTT over TCP используется для сбора данных, журнал сообщенй публикуются по доменам 
	path = \${prefix}/\${domain}/\${oid}

### Используется литература ###
[STD90]:  https://www.rfc-editor.org/rfc/rfc8259 "The JavaScript Object Notation (JSON) Data Interchange Format, 2017"
[STD94]:  https://www.rfc-editor.org/rfc/rfc8949 "Concise Binary Object Representation (CBOR), 2020"
[STD96]:  https://www.rfc-editor.org/rfc/rfc9052 "CBOR Object Signing and Encryption (COSE): Structures and Process, 2022"

[RFC5198]: https://www.rfc-editor.org/rfc/rfc5198 "Unicode Format for Network Interchang"
[RFC6256]: https://www.rfc-editor.org/rfc/rfc6256 "Using Self-Delimiting Numeric Values in Protocols"
[RFC6690]: https://www.rfc-editor.org/rfc/rfc6690 "Constrained RESTful Environments (CoRE) Link Format"
[RFC7252]: https://www.rfc-editor.org/rfc/rfc7252 "The Constrained Application Protocol (CoAP)"
[RFC7641]: https://www.rfc-editor.org/rfc/rfc7641 "Observing Resources in the Constrained Application Protocol (CoAP)"
[RFC7950]: https://www.rfc-editor.org/rfc/rfc7950 "The YANG 1.1 Data Modeling Language" 
[RFC7959]: https://www.rfc-editor.org/rfc/rfc7959 "Block-Wise Transfers in the Constrained Application Protocol (CoAP)"
[RFC8132]: https://www.rfc-editor.org/rfc/rfc8132 "PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)"
[RFC8152]: https://www.rfc-editor.org/rfc/rfc8259 "CBOR Object Signing and Encryption (COSE), July 2017"
[RFC8259]: https://www.rfc-editor.org/rfc/rfc8259 "The JavaScript Object Notation (JSON) Data Interchange Format, 2017"
[RFC8323]: https://www.rfc-editor.org/rfc/rfc8323 "CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets" 
[RFC8428]: https://www.rfc-editor.org/rfc/rfc8428 "Sensor Measurement Lists (SenML), August 2018"
[RFC8610]: https://www.rfc-editor.org/rfc/rfc8610 "Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures" 
[RFC8613]: https://www.rfc-editor.org/rfc/rfc8613 "Object Security for Constrained RESTful Environments (OSCORE)"
[RFC8710]: https://www.rfc-editor.org/rfc/rfc8710 "Multipart Content-Format for the Constrained Application Protocol (CoAP)"
[RFC8742]: https://www.rfc-editor.org/rfc/rfc8742 "Concise Binary Object Representation (CBOR) Sequences"
[RFC8746]: https://www.rfc-editor.org/rfc/rfc8746 "Concise Binary Object Representation (CBOR) Tags for Typed Arrays"
[RFC8949]: https://www.rfc-editor.org/rfc/rfc8949 "Concise Binary Object Representation (CBOR), 2020"
[RFC8974]: https://www.rfc-editor.org/rfc/rfc8974 "Extended Tokens and Stateless Clients in the Constrained Application Protocol (CoAP), Jan 2021"
[RFC9052]: https://www.rfc-editor.org/rfc/rfc9052 "CBOR Object Signing and Encryption (COSE): Structures and Process, 2022"
[RFC9090]: https://www.rfc-editor.org/rfc/rfc9090 "Concise Binary Object Representation (CBOR) Tags for Object Identifiers"
[RFC9175]: https://www.rfc-editor.org/rfc/rfc9175 "Constrained Application Protocol (CoAP): Echo, Request-Tag, and Token Processing"
[RFC9177]: https://www.rfc-editor.org/rfc/rfc9177 "Constrained Application Protocol (CoAP): Block-Wise Transfer Options Supporting Robust Transmission"
[RFC9176]: https://www.rfc-editor.org/rfc/rfc9176 "Constrained RESTful Environments (CoRE) Resource Directory"
[RFC9254]: https://www.rfc-editor.org/rfc/rfc9254 "Encoding of Data Modeled with YANG in the Concise Binary Object Representation (CBOR)"
[RFC9562]: https://www.rfc-editor.org/rfc/rfc9562 "Universally Unique IDentifiers (UUIDs)"
[RFC9581]: https://www.rfc-editor.org/rfc/rfc9581 "Concise Binary Object Representation (CBOR) Tags for Time, Duration, and Period"

[X.680]: https://www.itu.int/rec/T-REC-X.680 "Abstract Syntax Notation One (ASN.1): Specification of basic notation"
[X.690]: https://www.itu.int/rec/T-REC-X.690 "Abstract Syntax Notation One (ASN.1). Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"

[C]: 	<https://www.iso.org/standard/74528.html> "Programming languages - C, ISO/IEC 9899:2018, Fourth Edition, June 2018" 
[CPP]: 	<https://www.iso.org/standard/79358.html> "Programming languages - C++, ISO/IEC 14882:2020, Sixth Edition, December 2020"

[IANA.senml]: <https://www.iana.org/assignments/senml> "Sensor Measurement Lists (SenML)"
[IANA.core-param]: <https://www.iana.org/assignments/core-parameters/core-parameters.xhtml>
[OCF.spec]: <https://openconnectivity.org/developer/specifications/> "OCF Resource Type Specification"

[TC26]: <https://tc26.ru> " "
[TC26.Magma]: <https://tc26.ru> " "
[TC26.CRISP]:  https://tc26.ru/standarts/natsionalnye-standarty/gost-r-71252-2024-informatsionnaya-tekhnologiya-kriptograficheskaya-zashchita-informatsii-protokol-zashchishchennogo-obmena-dlya-industrialnykh-sistem.html 
"[ГОСТ Р 71252-2024] Информационная технология. Криптографическая защита информации. Протокол защищенного обмена для индустриальных систем"

[BACnet]: https://webstore.ansi.org/preview-pages/ASHRAE/preview_ANSI+ASHRAE+135-2020.pdf "ANSI/ASHRAE 135-2020 BACnet® - A Data Communication Protocol for Building Automation and Control Networks"

[SAE J1939 DBC]: 
